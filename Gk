local AimlockModule = {}

function AimlockModule.Init(player, char, camera)
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Workspace = game:GetService("Workspace")
	
	if AimlockModule._cleanup then
        AimlockModule._cleanup()
    end
	
    if not char then
        player.CharacterAdded:Wait()
        char = player.Character
    end
    
	local humanoid = char:WaitForChild("Humanoid")
	local AimlockPlayerEnabled, AimlockNpcEnabled, PredictionEnabled = false, false, false
	local currentTarget = nil
	local currentTool = nil
	local vActive, sharkZActive, cursedZActive = false, false, false
	local tiltEnabled = false
	local rightTouches = {}
	local tiltConn, preTiltCFrame, dmgConn = nil, nil, nil
	local connections = {}
	local currentEnemyTarget, currentBossTarget, currentHighlight = nil, nil, nil
	local healthConn, lastHealth = nil, nil
	local ESPs = {}
	local EXPANDED_SIZE = Vector3.new(15, 20, 15)
	local EXPANDED_HITBOX_SIZE = Vector3.new(40, 40, 40)
	local originalSizes = {}
	local createdHitboxes = {}
	local xSkillActive = false 
	local xHitboxActive = false
	
-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetPlayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetPlayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetPlayer)
	if not targetPlayer or targetPlayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetPlayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetPlayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

-- =========================
-- Enemies Finder
-- =========================
local function getNearestEnemy(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 100

	for _, p in pairs(Players:GetPlayers()) do
		if p ~= player and isEnemy(p) and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health > 0 then
				local enemyHRP = p.Character.HumanoidRootPart
				local dist = (enemyHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = enemyHRP
				end
			end
		end
	end

	return nearest
end

local function getNearestBoss(maxDistance)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local nearest, shortest = nil, maxDistance or 500
	local bossFolder = Workspace:FindFirstChild("Enemies")
	if bossFolder then
		for _, boss in pairs(bossFolder:GetChildren()) do
			local humanoid = boss:FindFirstChildOfClass("Humanoid")
			if boss:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
				local bossHRP = boss.HumanoidRootPart
				local dist = (bossHRP.Position - hrp.Position).Magnitude
				if dist < shortest then
					shortest = dist
					nearest = bossHRP
				end
			end
		end
	end
	return nearest
end

-- =========================
-- Tilt Camera Function
-- =========================
local function disconnectTiltConn()
	if tiltConn then
		tiltConn:Disconnect()
		tiltConn = nil
	end
end

local function stopTiltSmooth()
	disconnectTiltConn()
	if not preTiltCFrame then return end

	local startCF = camera.CFrame
	local endCF = preTiltCFrame
	preTiltCFrame = nil

	local a = 0
	local restoreConn
	restoreConn = RunService.RenderStepped:Connect(function(dt)
		a = math.min(a + dt * 5, 1)
		camera.CFrame = startCF:Lerp(endCF, a)
		if a >= 1 then
			restoreConn:Disconnect()
		end
	end)
end

local function startTilt()
	disconnectTiltConn()

	preTiltCFrame = preTiltCFrame or camera.CFrame
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	local startCF = camera.CFrame
	local camPos = startCF.Position

	local tiltOffset
	if humanoid.FloorMaterial ~= Enum.Material.Air then
		tiltOffset = Vector3.new(0, 6, 0)
	else
		tiltOffset = Vector3.new(0, 40, 0)
	end

	local downLook = hrp.Position - tiltOffset
	local targetCF = CFrame.new(camPos, downLook)

	local alpha = 0
	tiltConn = RunService.RenderStepped:Connect(function(dt)
		if not (tiltEnabled and next(rightTouches) and hrp.Parent) then
			stopTiltSmooth()
			return
		end

		if alpha < 1 then
			alpha = math.min(alpha + dt * 2, 1)
			camera.CFrame = startCF:Lerp(targetCF, alpha)
		else
			camera.CFrame = targetCF
		end
	end)
end

-- =========================
-- Hitbox Expander
-- =========================
local fightingStyles = {
    ["Godhuman"] = true,
    ["Sanguine Art"] = true,
    ["Dragon Talon"] = true,
    ["Electric Claw"] = true,
    ["Sharkman Karate"] = true,
    ["Death Step"] = true,
}

local function expandWeapon(weapon)
    if not currentTool or not fightingStyles[currentTool.Name] then return end
	for _, part in ipairs(weapon:GetDescendants()) do
		if part:IsA("BasePart") then
			if not originalSizes[part] then
				originalSizes[part] = part.Size
			end
			part.Size = EXPANDED_SIZE
			part.CanCollide = false
		end
	end
end

local function resetWeapon(weapon)
	for _, part in ipairs(weapon:GetDescendants()) do
		if part:IsA("BasePart") and originalSizes[part] then
			part.Size = originalSizes[part]
			originalSizes[part] = nil
		end
	end
end

local toolWatchers = setmetatable({}, {__mode = "k"}) -- weak keys

local function watchEquippedWeapon(char, tool)
	if not tool or not fightingStyles[tool.Name] then return end

    if toolWatchers[tool] then return end

    local watcher = {eqConn = nil, remConn = nil, descConns = {}, ancestryConn = nil}
    toolWatchers[tool] = watcher

    watcher.eqConn = char.ChildAdded:Connect(function(child)
		if child.Name == "EquippedWeapon" and child:IsA("Model") then
            if tool.Parent == char and fightingStyles[tool.Name] then
                expandWeapon(child)

                local descConn
                descConn = child.DescendantAdded:Connect(function(desc)
                    if desc:IsA("BasePart") then
                        if tool.Parent == char and fightingStyles[tool.Name] then
                            if not originalSizes[desc] then
                                originalSizes[desc] = desc.Size
                            end
                            desc.Size = EXPANDED_SIZE
                            desc.CanCollide = false
                        end
                    end
                end)
                table.insert(watcher.descConns, descConn)
            end
		end
	end)

    watcher.remConn = char.ChildRemoved:Connect(function(child)
        if child.Name == "EquippedWeapon" and child:IsA("Model") then
            resetWeapon(child)
        end
    end)

    local existing = char:FindFirstChild("EquippedWeapon")
    if existing and existing:IsA("Model") and tool.Parent == char and fightingStyles[tool.Name] then
        expandWeapon(existing)
    end

    watcher.ancestryConn = tool.AncestryChanged:Connect(function(_, parent)
        if not parent or parent ~= char then
            if watcher.eqConn and watcher.eqConn.Connected then watcher.eqConn:Disconnect() end
            if watcher.remConn and watcher.remConn.Connected then watcher.remConn:Disconnect() end
            for _, dc in ipairs(watcher.descConns) do
                if dc and dc.Connected then dc:Disconnect() end
            end
            watcher.descConns = {}

            if watcher.ancestryConn and watcher.ancestryConn.Connected then
                watcher.ancestryConn:Disconnect()
            end
            toolWatchers[tool] = nil

            local weapon = char:FindFirstChild("EquippedWeapon")
            if weapon then
                resetWeapon(weapon)
            end
        end
    end)
    table.insert(connections, watcher.eqConn)
    table.insert(connections, watcher.remConn)
    table.insert(connections, watcher.ancestryConn)
    for _, dc in ipairs(watcher.descConns) do
        table.insert(connections, dc)
    end
end

-- =========================
-- Tool equip / unequip 
-- =========================
local function hookTool(tool)
	currentTool = tool
	tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			currentTool = nil
			vActive = false
			sharkZActive = false
			cursedZActive = false
			tiltEnabled = false
			stopTiltSmooth()
            local w = toolWatchers[tool]
            if w then
                if w.eqConn and w.eqConn.Connected then w.eqConn:Disconnect() end
                if w.remConn and w.remConn.Connected then w.remConn:Disconnect() end
                for _, dc in ipairs(w.descConns) do
                    if dc and dc.Connected then dc:Disconnect() end
                end
                if w.ancestryConn and w.ancestryConn.Connected then w.ancestryConn:Disconnect() end
                toolWatchers[tool] = nil
            end
		end
	end)
end

char.ChildAdded:Connect(function(child)
	if child:IsA("Tool") and fightingStyles[child.Name] then
		hookTool(child)
		watchEquippedWeapon(char, child)
	end
end)

char.ChildRemoved:Connect(function(child)
	if child == currentTool then
		currentTool = nil
		vActive = false
		sharkZActive = false
		cursedZActive = false
		tiltEnabled = false
		stopTiltSmooth()
	end
	if child:IsA("Tool") and fightingStyles[child.Name] then
		local weapon = char:FindFirstChild("EquippedWeapon")
		if weapon then
			resetWeapon(weapon)
		end

        local w = toolWatchers[child]
        if w then
            if w.eqConn and w.eqConn.Connected then w.eqConn:Disconnect() end
            if w.remConn and w.remConn.Connected then w.remConn:Disconnect() end
            for _, dc in ipairs(w.descConns) do
                if dc and dc.Connected then dc:Disconnect() end
            end
            if w.ancestryConn and w.ancestryConn.Connected then w.ancestryConn:Disconnect() end
            toolWatchers[child] = nil
        end
	end
end)

-- =========================
-- V Skill Detection
-- =========================
local old
old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if (method == "InvokeServer" or method == "FireServer") then
        local a1 = args[1]

        if typeof(a1) == "string" and a1:upper() == "V" and currentTool and currentTool.Name == "Dough-Dough" then
            vActive = true
            local stamp = os.clock()
            task.delay(2, function()
                if os.clock() - stamp >= 2 then
                    vActive = false
                    if tiltEnabled and next(rightTouches) then
                        tiltEnabled = false
                        stopTiltSmooth()
                        rightTouches = {}
                    end
                end
            end)
        end

        if typeof(a1) == "string" and a1:upper() == "Z" and currentTool then
            if currentTool.Name == "Shark Anchor" then
                sharkZActive = true
            elseif currentTool.Name == "Cursed Dual Katana" then
                cursedZActive = true
            end
            if sharkZActive or cursedZActive then
                local stamp = os.clock()
                task.delay(2, function()
                    if os.clock() - stamp >= 2 then
                        sharkZActive = false
                        cursedZActive = false
                        if tiltEnabled and next(rightTouches) then
                            tiltEnabled = false
                            stopTiltSmooth()
                            rightTouches = {}
                        end
                    end
                end)
            end
        end

        if typeof(a1) == "string" and a1:upper() == "X" and currentTool then
            if currentTool.Name == "Shark Anchor" or currentTool.Name == "Cursed Dual Katana" or currentTool.Name == "TripleTrueKatana" then
                xSkillActive = true
            end
        end

        if self.Name == "EquipEvent" then
            local arg1 = args[1]
            if arg1 == false then
                currentTool = nil
                sharkZActive = false
                cursedZActive = false
                xSkillActive = false
                tiltEnabled = false
                stopTiltSmooth()
                rightTouches = {}
            end
        end
    end
    return old(self, ...)
end)

-- =========================
-- Tilt trigger condition
-- =========================
local function canTilt()
	return (currentTool and currentTool.Name == "Dough-Dough" and vActive)
	    or (currentTool and currentTool.Name == "Shark Anchor" and sharkZActive)
	    or (currentTool and currentTool.Name == "Cursed Dual Katana" and cursedZActive)
end

-- =========================
-- Swap function (integrated)
-- =========================

-- local function swapToGodhuman()
--	local char = player.Character
--	if not char then return end

--	local humanoid = char:FindFirstChildOfClass("Humanoid")
--	if not humanoid then return end

--	local equipped = char:FindFirstChildOfClass("Tool")
--	if equipped and equipped.Name == "Cursed Dual Katana" then
--		humanoid:UnequipTools()

--		local backpack = player:WaitForChild("Backpack")
--		local godhuman = backpack:FindFirstChild("Godhuman")
--		if godhuman then
--			humanoid:EquipTool(godhuman)
--		end
--	end
--end

-- =========================
-- Skill-X Hitbox Expander
-- =========================
local function expandHRP(targetModel)
    if not targetModel or not targetModel.Parent then return end
    if createdHitboxes[targetModel] then return end

    local hrp = targetModel:FindFirstChild("HumanoidRootPart")
    local humanoid = targetModel:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end

    local original = hrp.Size
    createdHitboxes[targetModel] = {
        hrp = hrp,
        originalSize = original,
        diedConn = nil,
        resetTimer = nil,
    }

    hrp.Size = EXPANDED_HITBOX_SIZE
    hrp.CanCollide = false
    hrp.Transparency = 0.20

    local diedConn
    diedConn = humanoid.Died:Connect(function()
        resetHRP(targetModel)
        if diedConn then
            diedConn:Disconnect()
            diedConn = nil
        end
    end)

    if createdHitboxes[targetModel] then
        createdHitboxes[targetModel].diedConn = diedConn
    else
        if diedConn then diedConn:Disconnect() end
    end
end

local function resetHRP(targetModel)
    if not targetModel then return end
    local entry = createdHitboxes[targetModel]
    if not entry then return end

    local hrp = entry.hrp
    if hrp and hrp.Parent and entry.originalSize then
        pcall(function()
            hrp.Size = entry.originalSize
        end)
    end

    if entry.diedConn and entry.diedConn.Connected then
        pcall(function() entry.diedConn:Disconnect() end)
    end

    if entry.resetTimer and type(entry.resetTimer) == "table" and entry.resetTimer.Disconnect then
        pcall(function() entry.resetTimer:Disconnect() end)
    end

    createdHitboxes[targetModel] = nil
end

-- ======= patched triggerXSkillHitbox =======
local function triggerXSkillHitbox()
    if not xSkillActive then
        -- debug
        print("[XHitbox] xSkillActive is false; aborting.")
        return
    end

    -- try to resolve the model to expand
    local targetModel = nil

    -- priority: currentTarget (model), then currentHighlight.Adornee.Parent, then if Adornee is HRP use that parent
    if currentTarget and currentTarget:IsA("Model") then
        targetModel = currentTarget
    elseif currentTarget and currentTarget:IsA("BasePart") and currentTarget.Parent and currentTarget.Parent:FindFirstChildOfClass("Humanoid") then
        targetModel = currentTarget.Parent
    elseif currentHighlight and currentHighlight.Adornee then
        local a = currentHighlight.Adornee
        if a:IsA("Model") then
            targetModel = a
        elseif a:IsA("BasePart") and a.Parent and a.Parent:FindFirstChildOfClass("Humanoid") then
            targetModel = a.Parent
        end
    end

    if not targetModel or not targetModel.Parent then
        print("[XHitbox] No valid targetModel resolved. currentTarget:", tostring(currentTarget), " highlightAdornee:", tostring(currentHighlight and currentHighlight.Adornee))
        return
    end

    if xHitboxActive then
        print("[XHitbox] xHitboxActive already true; skipping.")
        return
    end

    xHitboxActive = true
    print("[XHitbox] expanding HRP for target:", targetModel:GetFullName())

    expandHRP(targetModel)

    -- ensure reset runs even if something else clears states
    task.spawn(function()
        task.wait(4) -- keep expanded for 4 seconds (your original value)
        pcall(function() resetHRP(targetModel) end)
        xHitboxActive = false
        xSkillActive = false
        print("[XHitbox] reset HRP for target:", targetModel:GetFullName())
    end)
end

-- =========================
-- Touch tracking
-- =========================
UserInputService.TouchStarted:Connect(function(touch)
	if touch.Position.X > camera.ViewportSize.X / 2 then
		rightTouches[touch] = true
		if tiltEnabled and canTilt() then
			startTilt()
		end
	end
end)

UserInputService.TouchEnded:Connect(function(touch)
	if rightTouches[touch] then
		rightTouches[touch] = nil
		if not next(rightTouches) then
			stopTiltSmooth()
		    if xSkillActive then
		        triggerXSkillHitbox()
		    end
			
			--if currentTool and currentTool.Name == "Cursed Dual Katana" and cursedZActive and tiltEnabled then
				--swapToGodhuman()
			--end

			tiltEnabled = false
			vActive = false
			sharkZActive = false
			cursedZActive = false
		end
	end
end)

-- =========================
-- Damage Counter Watch
-- =========================
local function watchDamageCounter()
    if dmgConn then
        dmgConn:Disconnect()
        dmgConn = nil
    end

    local dmgCounterPath = player:WaitForChild("PlayerGui")
        :WaitForChild("Main")
        :WaitForChild("DmgCounter")
        :WaitForChild("Text")

    dmgConn = dmgCounterPath:GetPropertyChangedSignal("Text"):Connect(function()
        local dmgText = tonumber(dmgCounterPath.Text) or 0

        if dmgText > 0 and canTilt() and currentHighlight then
            tiltEnabled = true
            if next(rightTouches) then
                startTilt()
            end
        else
            tiltEnabled = false
            stopTiltSmooth()
        end
    end)
    table.insert(connections, dmgConn)
end

-- =========================
-- Health Watch for Tilt Reset
-- =========================
local function watchHealth(humanoid)
    if healthConn then
        healthConn:Disconnect()
        healthConn = nil
    end

    lastHealth = humanoid.Health

    healthConn = humanoid.HealthChanged:Connect(function(newHealth)
        if tiltEnabled and next(rightTouches) then
            if newHealth < lastHealth then
                tiltEnabled = false
                stopTiltSmooth()
                rightTouches = {}
            end
        end
        lastHealth = newHealth
    end)
    table.insert(connections, healthConn)
end

local targetDeathConn -- store death connection globally so we can clean it

local function setAimlockTarget(targetModel)
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    if targetDeathConn then
        targetDeathConn:Disconnect()
        targetDeathConn = nil
    end

    currentTarget = targetModel

    if targetModel then
        local highlight = Instance.new("Highlight")
        highlight.FillColor = Color3.new(1, 1, 0) -- yellow
        highlight.OutlineColor = Color3.new(1, 1, 0)
        highlight.FillTransparency = 0.5
        highlight.Adornee = targetModel
        highlight.Parent = targetModel
        currentHighlight = highlight

        local humanoid = targetModel:FindFirstChildOfClass("Humanoid")
        if humanoid then
            targetDeathConn = humanoid.Died:Connect(function()
                if currentHighlight then
                    currentHighlight:Destroy()
                    currentHighlight = nil
                end
                if targetDeathConn then
                    targetDeathConn:Disconnect()
                    targetDeathConn = nil
                end
                currentTarget = nil
            end)
            if currentTarget ~= targetModel then
	            watchDamageCounter()
	        end
        end
        currentTarget = targetModel
    end
end

local renderConnTilt = RunService.RenderStepped:Connect(function()
	local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    if not tiltEnabled then
        if AimlockPlayerEnabled then
            if not currentEnemyTarget or not currentEnemyTarget.Parent 
                or not currentEnemyTarget.Parent:FindFirstChildOfClass("Humanoid") 
                or currentEnemyTarget.Parent:FindFirstChildOfClass("Humanoid").Health <= 0 then
                currentEnemyTarget = getNearestEnemy(500)
            end

            if currentEnemyTarget then
                local enemyHRP = currentEnemyTarget
				local dist = (enemyHRP.Position - camera.CFrame.Position).Magnitude
				local predictionTime = math.clamp(dist / 150, 0.1, 0.3) 
				local enemyVelocity = enemyHRP.Velocity
				local predictedPos
				if PredictionEnabled and enemyVelocity.Magnitude > 3 then
				    predictedPos = enemyHRP.Position + enemyVelocity * predictionTime
				else
				    predictedPos = enemyHRP.Position
				end
				local yOffset = math.clamp(dist / 40, 0, 0.06)  
				local lookVector = (predictedPos - camera.CFrame.Position).Unit
				local tiltedlook = Vector3.new(lookVector.X, lookVector.Y - yOffset, lookVector.Z).Unit
				camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + tiltedlook)
            end
        elseif AimlockNpcEnabled then
            if not currentBossTarget or not currentBossTarget.Parent 
                or not currentBossTarget.Parent:FindFirstChildOfClass("Humanoid") 
                or currentBossTarget.Parent:FindFirstChildOfClass("Humanoid").Health <= 0 then
                currentBossTarget = getNearestBoss(500)
            end

            if currentBossTarget then  
	            local enemyHRP = currentBossTarget
				local dist = (enemyHRP.Position - camera.CFrame.Position).Magnitude
				local predictionTime = math.clamp(dist / 150, 0.1, 0.3) 
				local enemyVelocity = enemyHRP.Velocity
				local predictedPos
				if PredictionEnabled and enemyVelocity.Magnitude > 3 then
				    predictedPos = enemyHRP.Position + enemyVelocity * predictionTime
				else
				    predictedPos = enemyHRP.Position
				end
				local yOffset = math.clamp(dist / 40, 0, 0.06)  
				local lookVector = (predictedPos - camera.CFrame.Position).Unit
				local tiltedlook = Vector3.new(lookVector.X, lookVector.Y - yOffset, lookVector.Z).Unit
				camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + tiltedlook)
            end
        end
    end
    
    if AimlockPlayerEnabled and currentEnemyTarget then
        if currentTarget ~= currentEnemyTarget.Parent then
            setAimlockTarget(currentEnemyTarget.Parent)
        end
    elseif AimlockNpcEnabled and currentBossTarget then
        if currentTarget ~= currentBossTarget.Parent then
            setAimlockTarget(currentBossTarget.Parent)
        end
    else
        if currentTarget then
            setAimlockTarget(nil)
        end
    end
end)
table.insert(connections, renderConnTilt)

-- =========================
-- Ability V2
-- =========================
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CommE = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CommE")

local cooldownTime = 31

local function clickActivateAbility()
	CommE:FireServer("ActivateAbility")

	task.wait(cooldownTime)
end

task.spawn(function()
	while true do
		clickActivateAbility()
	end
end)

-- =========================
-- Global Player ESP with Colors
-- =========================
local espFolder = Instance.new("Folder")
espFolder.Name = "GlobalESP"
espFolder.Parent = game.CoreGui

local function getESPColor(player)
	if player == game.Players.LocalPlayer then
		return Color3.fromRGB(0, 255, 0)
	elseif isAllyWithMe(player) then
		return Color3.fromRGB(0, 255, 0)
	elseif isEnemy(player) then
		return Color3.fromRGB(255, 255, 0)
	else
		return Color3.fromRGB(0, 255, 0)
	end
end

local function createESP(player)
	if ESPs[player] then
		ESPs[player]:Destroy()
		ESPs[player] = nil
	end

	local char = player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = player.Name
	billboard.Adornee = head
	billboard.Size = UDim2.new(0, 200, 0, 50)
	billboard.AlwaysOnTop = true
	billboard.StudsOffset = Vector3.new(0, 2, 0) 
	billboard.Parent = espFolder

	local textLabel = Instance.new("TextLabel")
	textLabel.Size = UDim2.new(1, 0, 1, 0)
	textLabel.BackgroundTransparency = 1
	textLabel.Text = player.DisplayName -- DisplayName used
	textLabel.TextColor3 = getESPColor(player)
	textLabel.TextStrokeTransparency = 0
	textLabel.Font = Enum.Font.SourceSansBold
	textLabel.TextSize = 16
	textLabel.Parent = billboard

	ESPs[player] = billboard
end

local function removeESP(player)
	if ESPs[player] then
		ESPs[player]:Destroy()
		ESPs[player] = nil
	end
end

game:GetService("RunService").RenderStepped:Connect(function()
	for player, billboard in pairs(ESPs) do
		if billboard and billboard:FindFirstChildOfClass("TextLabel") then
			billboard.TextLabel.TextColor3 = getESPColor(player)
		end
	end
end)

local function setupPlayerESP(player)
	player.CharacterAdded:Connect(function(char)
		task.wait(0.5) -- wait for head to exist
		createESP(player)
	end)
	if player.Character then
		task.wait(0.5)
		createESP(player)
	end
end

for _, p in pairs(game.Players:GetPlayers()) do
	if p ~= game.Players.LocalPlayer then
		setupPlayerESP(p)
	end
end

game.Players.PlayerAdded:Connect(function(p)
	if p ~= game.Players.LocalPlayer then
		setupPlayerESP(p)
	end
end)

game.Players.PlayerRemoving:Connect(removeESP)

-- =========================
-- Cleanup 
-- =========================
local function cleanup()
    for _, conn in pairs(connections) do
        if conn.Connected then
            conn:Disconnect()
        end
    end
    connections = {}
    
    if targetDeathConn then
	    targetDeathConn:Disconnect()
	    targetDeathConn = nil
	end

    if dmgConn then
        dmgConn:Disconnect()
        dmgConn = nil
    end
    
    if healthConn then
        healthConn:Disconnect()
        healthConn = nil
    end
    
    for player, billboard in pairs(ESPs) do
        if billboard then
            billboard:Destroy()
        end
    end 
    ESPs = {}

    if espFolder and espFolder.Parent then
        espFolder:Destroy()
    end
    
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
    end
    
    for targetModel, entry in pairs(createdHitboxes) do
        pcall(function()
            resetHRP(targetModel)
        end)
        createdHitboxes[targetModel] = nil
    end
    
    for part, size in pairs(originalSizes) do
        if part and part.Parent then
            part.Size = size
        end
    end
    originalSizes = {}

    disconnectTiltConn()

    currentTool = nil
    rightTouches = {}
    vActive = false
    sharkZActive = false
    cursedZActive = false
    tiltEnabled = false
    preTiltCFrame = nil
    lastHealth = nil
end

AimlockModule._cleanup = cleanup

-- =========================
-- lifecycle
-- =========================
player.CharacterAdded:Connect(function(c)
	cleanup()
	char = c
	humanoid = char:WaitForChild("Humanoid")
	vActive = false
	sharkZActive = false
	cursedZActive = false
	tiltEnabled = false
	rightTouches = {}
	stopTiltSmooth()
	watchHealth(humanoid)
end)

player.CharacterRemoving:Connect(function()
	vActive = false
	sharkZActive = false
	cursedZActive = false
	tiltEnabled = false
	rightTouches = {}
	disconnectTiltConn()
	currentTool = nil
end)

	-- =========================
	-- RETURN TABLE FOR MAIN SCRIPT USAGE
	-- =========================
	return {
		toggleAimlock = function(state)
			AimlockPlayerEnabled = state
			if not state then
			    currentEnemyTarget = nil  
			end 
		end,
		toggleBossAimlock = function(state)
			AimlockNpcEnabled = state
			if not state then
			    currentBossTarget = nil
			end
		end,
		togglePrediction = function(state)
	        PredictionEnabled = state
	    end,
		cleanup = cleanup
	}
end

return AimlockModule
