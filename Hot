local AimlockModule = {}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local camera = workspace.CurrentCamera
local player = Players.LocalPlayer

local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

-- =========================
-- State variables
-- =========================
local AimlockPlayerEnabled, AimlockNpcEnabled, PredictionEnabled = false, false, false
local MiniPlayerState, MiniNpcState = nil, nil
local MiniPlayerCreated, MiniNpcCreated = false, false
local currentTarget, currentTool = nil, nil
local MiniPlayerGui, MiniNpcGui = nil, nil
local vActive, sharkZActive, cursedZActive, tiltEnabled = false, false, false, false
local rightTouches = {}
local tiltConn, preTiltCFrame, dmgConn, healthConn, currentHighlight = nil, nil, nil, nil, nil
local lastHealth = nil
local lastSearch = 0
local searchInterval = 0.15 -- reduced frequency for mobile
local cachedEnemy, cachedBoss = nil, nil

-- =========================
-- Utility functions
-- =========================
local function resetTiltFlags()
    vActive, sharkZActive, cursedZActive, tiltEnabled = false, false, false, false
    rightTouches = {}
    if tiltConn then tiltConn:Disconnect() tiltConn = nil end
    preTiltCFrame = nil
end

local function isAllyWithMe(targetPlayer)
    local myGui = player:FindFirstChild("PlayerGui")
    if not myGui then return false end

    local scrolling = myGui:FindFirstChild("Main") and myGui.Main:FindFirstChild("Allies")
        and myGui.Main.Allies:FindFirstChild("Container") and myGui.Main.Allies.Container:FindFirstChild("Allies")
        and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

    if scrolling then
        for _, frame in pairs(scrolling:GetDescendants()) do
            if frame:IsA("ImageButton") and frame.Name == targetPlayer.Name then
                return true
            end
        end
    end
    return false
end

local function isEnemy(targetPlayer)
    if not targetPlayer or targetPlayer == player then return false end
    local myTeam, targetTeam = player.Team, targetPlayer.Team
    if myTeam and targetTeam then
        if (myTeam.Name == "Pirates" and targetTeam.Name == "Marines") or
           (myTeam.Name == "Marines" and targetTeam.Name == "Pirates") then
            return true
        elseif myTeam.Name == targetTeam.Name then
            if myTeam.Name == "Pirates" and isAllyWithMe(targetPlayer) then return false end
            return myTeam.Name == "Pirates" -- Pirates vs Pirates = enemy if not ally
        end
    end
    return true
end

-- =========================
-- Find nearest targets
-- =========================
local function getNearestEnemy(maxDistance)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local nearest, shortest = nil, maxDistance or 100
    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and isEnemy(p) and p.Character then
            local hum = p.Character:FindFirstChildOfClass("Humanoid")
            local enemyHRP = p.Character:FindFirstChild("HumanoidRootPart")
            if hum and hum.Health > 0 and enemyHRP then
                local dist = (enemyHRP.Position - hrp.Position).Magnitude
                if dist < shortest then shortest = dist nearest = enemyHRP end
            end
        end
    end
    return nearest
end

local function getNearestBoss(maxDistance)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local nearest, shortest = nil, maxDistance or 500
    local bossFolder = Workspace:FindFirstChild("Enemies")
    if bossFolder then
        for _, boss in pairs(bossFolder:GetChildren()) do
            local hum = boss:FindFirstChildOfClass("Humanoid")
            local hrpBoss = boss:FindFirstChild("HumanoidRootPart")
            if hum and hum.Health > 0 and hrpBoss then
                local dist = (hrpBoss.Position - hrp.Position).Magnitude
                if dist < shortest then shortest = dist nearest = hrpBoss end
            end
        end
    end
    return nearest
end

-- =========================
-- Tilt camera
-- =========================
local function stopTiltSmooth()
    if tiltConn then tiltConn:Disconnect() tiltConn = nil end
    if not preTiltCFrame then return end
    local startCF, endCF = camera.CFrame, preTiltCFrame
    preTiltCFrame = nil
    local a = 0
    local restoreConn
    restoreConn = RunService.RenderStepped:Connect(function(dt)
        a = math.min(a + dt * 5, 1)
        camera.CFrame = startCF:Lerp(endCF, a)
        if a >= 1 then restoreConn:Disconnect() end
    end)
end

local function startTilt()
    if not char:FindFirstChild("HumanoidRootPart") then return end
    preTiltCFrame = preTiltCFrame or camera.CFrame
    local hrp = char.HumanoidRootPart
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    local camPos = camera.CFrame.Position
    local tiltOffset = (humanoid.FloorMaterial ~= Enum.Material.Air) and Vector3.new(0,6,0) or Vector3.new(0,40,0)
    local targetCF = CFrame.new(camPos, hrp.Position - tiltOffset)
    local alpha = 0

    tiltConn = RunService.RenderStepped:Connect(function(dt)
        if not (tiltEnabled and next(rightTouches) and hrp.Parent) then stopTiltSmooth() return end
        alpha = math.min(alpha + dt * 2, 1)
        camera.CFrame = (alpha < 1) and camera.CFrame:Lerp(targetCF, alpha) or targetCF
    end)
end

local function canTilt()
    return (currentTool and currentTool.Name == "Dough-Dough" and vActive)
       or (currentTool and currentTool.Name == "Shark Anchor" and sharkZActive)
       or (currentTool and currentTool.Name == "Cursed Dual Katana" and cursedZActive)
end

-- =========================
-- Mini UI
-- =========================
local function createMiniToggle(name, position, stateVarRef, realVarSetter)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = name .. "MiniToggleGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = player:WaitForChild("PlayerGui")

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 80, 0, 80)
    button.Position = position
    button.TextScaled = true
    button.TextColor3 = Color3.fromRGB(255,255,255)
    button.BackgroundColor3 = Color3.fromRGB(30,30,30)
    button.BorderSizePixel = 0
    button.Parent = screenGui

    local uicorner = Instance.new("UICorner")
    uicorner.CornerRadius = UDim.new(0,8)
    uicorner.Parent = button

    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new(Color3.fromRGB(255,100,50), Color3.fromRGB(255,200,50))
    gradient.Rotation = 45
    gradient.Parent = button

    local function updateUI(state)
        button.Text = name .. (state and " ON" or " OFF")
        gradient.Color = ColorSequence.new(
            state and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,200,50),
            state and Color3.fromRGB(50,200,50) or Color3.fromRGB(255,100,50)
        )
    end

    button.MouseButton1Click:Connect(function()
        stateVarRef.value = not stateVarRef.value
        realVarSetter(stateVarRef.value)
        updateUI(stateVarRef.value)
    end)

    -- Drag
    local dragging, dragStart, startPos = false, nil, nil
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true dragStart = input.Position startPos = button.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging=false end end)
        end
    end)
    button.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType==Enum.UserInputType.Touch or input.UserInputType==Enum.UserInputType.MouseMovement) then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(
                0, math.clamp(startPos.X.Offset + delta.X,0,camera.ViewportSize.X-button.AbsoluteSize.X),
                0, math.clamp(startPos.Y.Offset + delta.Y,0,camera.ViewportSize.Y-button.AbsoluteSize.Y)
            )
        end
    end)

    updateUI(stateVarRef.value) -- initial
    return screenGui
end

-- =========================
-- Tool handling
-- =========================
local function hookTool(tool)
    currentTool = tool
    tool.AncestryChanged:Connect(function(_, parent)
        if not parent then resetTiltFlags() currentTool=nil end
    end)
end

char.ChildAdded:Connect(function(child) if child:IsA("Tool") then hookTool(child) end end)
char.ChildRemoved:Connect(function(child) if child == currentTool then resetTiltFlags() currentTool=nil end end)

-- =========================
-- Hook V/Z skills
-- =========================
local old
old = hookmetamethod(game, "__namecall", function(self,...)
    local method = getnamecallmethod()
    local args = {...}

    if method=="InvokeServer" or method=="FireServer" then
        local a1 = args[1]
        if typeof(a1)=="string" then
            local str = a1:upper()
            if str=="V" and currentTool and currentTool.Name=="Dough-Dough" then
                vActive = true
                task.delay(2,function() vActive=false if tiltEnabled and next(rightTouches) then resetTiltFlags() end end)
            elseif str=="Z" and currentTool then
                if currentTool.Name=="Shark Anchor" then
                    sharkZActive = true
                    task.delay(2,function() sharkZActive=false if tiltEnabled and next(rightTouches) then resetTiltFlags() end end)
                elseif currentTool.Name=="Cursed Dual Katana" then
                    cursedZActive = true
                    task.delay(2,function() cursedZActive=false if tiltEnabled and next(rightTouches) then resetTiltFlags() end end)
                end
            end
        end

        if currentTool and currentTool.Name=="Shark Anchor" and self.Name=="EquipEvent" then
            if args[1]==false then resetTiltFlags() currentTool=nil end
        end
    end
    return old(self,...)
end)

-- =========================
-- Touch tracking
-- =========================
UserInputService.TouchStarted:Connect(function(touch)
    if touch.Position.X > camera.ViewportSize.X/2 then
        rightTouches[touch]=true
        if tiltEnabled and canTilt() then startTilt() end
    end
end)
UserInputService.TouchEnded:Connect(function(touch)
    if rightTouches[touch] then
        rightTouches[touch]=nil
        if not next(rightTouches) then resetTiltFlags() end
    end
end)

-- =========================
-- Aimlock & Highlight
-- =========================
local function setAimlockTarget(targetModel)
    if currentHighlight then currentHighlight:Destroy() currentHighlight=nil end
    if not targetModel then currentTarget=nil return end
    local hum = targetModel:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health<=0 then currentTarget=nil return end

    local highlight = Instance.new("Highlight")
    highlight.FillColor=Color3.fromRGB(255,255,0)
    highlight.OutlineColor=Color3.fromRGB(255,255,0)
    highlight.FillTransparency=0.5
    highlight.OutlineTransparency=0
    highlight.Adornee=targetModel
    highlight.Parent=targetModel
    currentHighlight=highlight

    hum.Died:Connect(function()
        if currentHighlight then currentHighlight:Destroy() currentHighlight=nil end
        currentTarget=nil
    end)
    currentTarget=targetModel
end

-- =========================
-- RenderStepped Aimlock
-- =========================
RunService.RenderStepped:Connect(function(dt)
    if not char:FindFirstChild("HumanoidRootPart") then return end
    lastSearch += dt
    if lastSearch >= searchInterval then
        lastSearch = 0
        if AimlockPlayerEnabled then
            if not cachedEnemy or not cachedEnemy.Parent or cachedEnemy.Parent:FindFirstChildOfClass("Humanoid") == nil
               or cachedEnemy.Parent:FindFirstChildOfClass("Humanoid").Health<=0 then
                cachedEnemy=getNearestEnemy(500)
            end
        else cachedEnemy=nil end

        if AimlockNpcEnabled then
            if not cachedBoss or not cachedBoss.Parent or cachedBoss.Parent:FindFirstChildOfClass("Humanoid")==nil
               or cachedBoss.Parent:FindFirstChildOfClass("Humanoid").Health<=0 then
                cachedBoss=getNearestBoss(500)
            end
        else cachedBoss=nil end
    end

    -- Aimlock rotation
    if not tiltEnabled then
        local targetHRP = AimlockPlayerEnabled and cachedEnemy or AimlockNpcEnabled and cachedBoss or nil
        if targetHRP then
            local camPos=camera.CFrame.Position
            local dist=(targetHRP.Position-camPos).Magnitude
            local predTime=math.clamp(dist/150,0.1,0.3)
            local predictedPos=PredictionEnabled and targetHRP.Velocity.Magnitude>3 and targetHRP.Position+targetHRP.Velocity*predTime or targetHRP.Position
            local yOffset=math.clamp(dist/40,0,0.06)
            local lookVector=(predictedPos-camPos).Unit
            camera.CFrame=CFrame.new(camPos, camPos + Vector3.new(lookVector.X, lookVector.Y-yOffset, lookVector.Z).Unit)
        end
    end

    -- Highlight target
    if AimlockPlayerEnabled and cachedEnemy and currentTarget~=cachedEnemy.Parent then
        setAimlockTarget(cachedEnemy.Parent)
    elseif AimlockNpcEnabled and cachedBoss and currentTarget~=cachedBoss.Parent then
        setAimlockTarget(cachedBoss.Parent)
    elseif not cachedEnemy and not cachedBoss and currentTarget then
        setAimlockTarget(nil)
    end
end)

-- =========================
-- Character lifecycle
-- =========================
player.CharacterAdded:Connect(function(c)
    char=c
    humanoid=char:WaitForChild("Humanoid")
    resetTiltFlags()
    lastHealth=humanoid.Health
end)
player.CharacterRemoving:Connect(function() resetTiltFlags() currentTool=nil end)

-- =========================
-- Public API
-- =========================
function AimlockModule:SetPlayerAimlock(state) AimlockPlayerEnabled=state end
function AimlockModule:SetNpcAimlock(state) AimlockNpcEnabled=state end
function AimlockModule:SetPrediction(state) PredictionEnabled=state end

function AimlockModule:SetMiniTogglePlayerAimlock(state)
    if not MiniPlayerCreated and state then
        MiniPlayerState={value=AimlockPlayerEnabled}
        MiniPlayerGui=createMiniToggle("Player",UDim2.new(0,10,0,90),MiniPlayerState,function(val) AimlockPlayerEnabled=val end)
        MiniPlayerCreated=true
    elseif MiniPlayerCreated then
        MiniPlayerState.value=state
        if MiniPlayerGui then MiniPlayerGui.Enabled=state end
    end
end

function AimlockModule:SetMiniToggleNpcAimlock(state)
    if not MiniNpcCreated and state then
        MiniNpcState={value=AimlockNpcEnabled}
        MiniNpcGui=createMiniToggle("NPC",UDim2.new(0,10,0,50),MiniNpcState,function(val) AimlockNpcEnabled=val end)
        MiniNpcCreated=true
    elseif MiniNpcCreated then
        MiniNpcState.value=state
        if MiniNpcGui then MiniNpcGui.Enabled=state end
    end
end

return AimlockModule
