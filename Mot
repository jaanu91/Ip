local OthersStuffsModule = {}

local HttpService = game:GetService("HttpService")

local WEBHOOK_URL = "https://discord.com/api/webhooks/1423244037879500820/lVUOGobehC6j-mT2IJAuDF8qAkeaWEViPMHa5gFvXDPHIicGj-9UqSUv2sFQtx-EwSrF"

local SETTINGS_FILE = "SapiHub_Settings.json"
local Settings = {}

function OthersStuffsModule.LoadSettings()
    if isfile and isfile(SETTINGS_FILE) then
        local success, data = pcall(function()
            return HttpService:JSONDecode(readfile(SETTINGS_FILE))
        end)
        if success and data then
            Settings = data
        else
            Settings = {}
        end
    else
        Settings = {}
    end
    return Settings
end

function OthersStuffsModule.SaveSettings(newSettings)
    Settings = newSettings or Settings
    if writefile then
        writefile(SETTINGS_FILE, HttpService:JSONEncode(Settings))
    end
end

function OthersStuffsModule.ResetSettings()
    if delfile and isfile and isfile(SETTINGS_FILE) then
        delfile(SETTINGS_FILE)
    end
    Settings = {}
end

function OthersStuffsModule.GetSettings()
    return Settings
end

function OthersStuffsModule:ApplySettings(Settings, Modules, Toggles)
    if Settings["AimlockPlayers"] ~= nil then
        Modules.Aimlock:SetPlayerAimlock(Settings["AimlockPlayers"])
        Toggles.AimlockPlayers:UpdateToggle(nil, Settings["AimlockPlayers"])
    end

    if Settings["AimlockPlayersMiniTogglePlayers"] ~= nil then
        Modules.Aimlock:SetMiniTogglePlayerAimlock(Settings["AimlockPlayersMiniTogglePlayers"])
        Toggles.AimlockPlayersMiniTogglePlayers:UpdateToggle(nil, Settings["AimlockPlayersMiniTogglePlayers"])
    end

    if Settings["AimlockNPC"] ~= nil then
        Modules.Aimlock:SetNpcAimlock(Settings["AimlockNPC"])
        Toggles.AimlockNPC:UpdateToggle(nil, Settings["AimlockNPC"])
    end

    if Settings["PredictionAmount"] then
        Modules.Aimlock:SetPredictionTime(Settings["PredictionAmount"])
    end

    if Settings["SilentAimPlayers"] ~= nil then
        Modules.SilentAim:SetPlayerSilentAim(Settings["SilentAimPlayers"])
        Toggles.SilentAimPlayers:UpdateToggle(nil, Settings["SilentAimPlayers"])
    end

    if Settings["SilentAimNPC"] ~= nil then
        Modules.SilentAim:SetNPCSilentAim(Settings["SilentAimNPC"])
        Toggles.SilentAimNPC:UpdateToggle(nil, Settings["SilentAimNPC"])
    end
    
    if Settings["SilentAimPediction"] ~= nil then
        Modules.SilentAim:SetPrediction(Settings["SilentAimPediction"])
        Toggles.SilentAimPediction:UpdateToggle(nil, Settings["SilentAimPediction"])
    end

    if Settings["SilentAimPredictionFuture"] then
        Modules.SilentAim:SetPredictionAmount(Settings["SilentAimPredictionFuture"])
    end

    if Settings["SilentAimDistanceLimit"] then
        Modules.SilentAim:SetDistanceLimit(Settings["SilentAimDistanceLimit"])
    end

    if Settings["ESPPlayers"] ~= nil then
        Modules.ESP:SetESP(Settings["ESPPlayers"])
        Toggles.ESPPlayers:UpdateToggle(nil, Settings["ESPPlayers"])
    end
    
    if Settings["BunnyHop"] ~= nil then
        Modules.ESP:SetBunnyhop(Settings["BunnyHop"])
        Toggles.BunnyHop:UpdateToggle(nil, Settings["BunnyHop"])
    end
    
    if Settings["V3Skill"] ~= nil then
        Modules.ESP:SetV3(Settings["V3Skill"])
        Toggles.V3Skill:UpdateToggle(nil, Settings["V3Skill"])
    end
    
    if Settings["AuraSkill"] ~= nil then
        Modules.ESP:SetBuso(Settings["AuraSkill"])
        Toggles.AuraSkill:UpdateToggle(nil, Settings["AuraSkill"])
    end

    if Settings["AntiAFK"] ~= nil then
        Modules.ESP:SetAntiAfk(Settings["AntiAFK"])
        Toggles.AntiAFK:UpdateToggle(nil, Settings["AntiAFK"])
    end

    if Settings["FpsOrPings"] ~= nil then
        Modules.Stuffs:SetPingsOrFps(Settings["FpsOrPings"])
        Toggles.FpsOrPings:UpdateToggle(nil, Settings["FpsOrPings"])
    end

    if Settings["FpsBoost"] ~= nil then
        Modules.Stuffs:SetFpsBoost(Settings["FpsBoost"])
        Toggles.FpsBoost:UpdateToggle(nil, Settings["FpsBoost"])
    end

    if Settings["INFEnergy"] ~= nil then
        Modules.Stuffs:SetINFEnergy(Settings["INFEnergy"])
        Toggles.INFEnergy:UpdateToggle(nil, Settings["INFEnergy"])
    end

    if Settings["FastAttack"] ~= nil then
        Modules.Stuffs:SetFastAttack(Settings["FastAttack"])
        Toggles.FastAttack:UpdateToggle(nil, Settings["FastAttack"])
    end

    if Settings["WalkonWater"] ~= nil then
        Modules.Stuffs:SetWalkWater(Settings["WalkonWater"])
        Toggles.WalkonWater:UpdateToggle(nil, Settings["WalkonWater"])
    end
    
    if Settings["V4"] ~= nil then
        Modules.Ui:SetV4(Settings["V4"])
        Toggles.V4:UpdateToggle(nil, Settings["V4"])
    end
    
    if Settings["FruitCheck"] ~= nil then
        Modules.Ui:SetFruitCheck(Settings["FruitCheck"])
        Toggles.FruitCheck:UpdateToggle(nil, Settings["FruitCheck"])
    end
    
    if Settings["TeleportFruit"] ~= nil then
        Modules.Ui:SetTeleportFruit(Settings["TeleportFruit"])
        Toggles.TeleportFruit:UpdateToggle(nil, Settings["TeleportFruit"])
    end
    
    if Settings["AutoKen"] ~= nil then
        Modules.SilentAim:SetAutoKen(Settings["AutoKen"])
        Toggles.AutoKen:UpdateToggle(nil, Settings["AutoKen"])
    end
    
    if Settings["Highlight"] ~= nil then
        Modules.SilentAim:SetHighlight(Settings["Highlight"])
        Toggles.Highlight:UpdateToggle(nil, Settings["Highlight"])
    end
    
    if Settings["SilentMiniToggleNPC"] ~= nil then
        Modules.SilentAim:SetMiniToggleNpcSilentAim(Settings["SilentMiniToggleNPC"])
        Toggles.SilentMiniToggleNPC:UpdateToggle(nil, Settings["SilentMiniToggleNPC"])
    end
    
    if Settings["SilentMiniTogglePlayers"] ~= nil then
        Modules.SilentAim:SetMiniTogglePlayerSilentAim(Settings["SilentMiniTogglePlayers"])
        Toggles.SilentMiniTogglePlayers:UpdateToggle(nil, Settings["SilentMiniTogglePlayers"])
    end
    
    if Settings["ZSkills"] ~= nil then
        Modules.Zskill:SetZSkills(Settings["ZSkills"])
        Toggles.ZSkills:UpdateToggle(nil, Settings["ZSkills"])
    end
    
    if Settings["Zskillmone"] ~= nil then
        Modules.SilentAim:SetZSkillorM1(Settings["Zskillmone"])
        Toggles.Zskillmone:UpdateToggle(nil, Settings["Zskillmone"])
    end
    if Settings["Dodge"] ~= nil then
        Modules.ESP:SetNoDodgeCD(Settings["Dodge"])
        Toggles.Dodge:UpdateToggle(nil, Settings["Dodge"])
    end
    if Settings["Lava"] ~= nil then
        Modules.Stuffs:SetLava(Settings["Lava"])
        Toggles.Lava:UpdateToggle(nil, Settings["Lava"])
    end
    if Settings["Fog"] ~= nil then
        Modules.Stuffs:SetFog(Settings["Fog"])
        Toggles.Fog:UpdateToggle(nil, Settings["Fog"])
    end
end

local FruitsToCheck = {
    "Bomb Fruit","Eagle Fruit","Blade Fruit","Diamond Fruit","Spike Fruit","Rubber Fruit",
    "Light Fruit","Smoke Fruit","Flame Fruit","Spring Fruit","Falcon Fruit","Ice Fruit",
    "Sand Fruit","Dark Fruit","Ghost Fruit","Creation Fruit","Magma Fruit","Quake Fruit",
    "Buddha Fruit","Love Fruit","Spider Fruit","Sound Fruit","Phoenix Fruit","Portal Fruit",
    "Pain Fruit","Blizzard Fruit","Gravity Fruit","Mammoth Fruit","T-Rex Fruit","Yeti Fruit",
    "Dough Fruit","Shadow Fruit","Venom Fruit","Control Fruit","Gas Fruit","Spirit Fruit",
    "Dragon Fruit","Leopard Fruit","Kitsune Fruit"
}

local SeaNames = {
    [2753915549] = "Sea 1",
    [4442272183] = "Sea 2",
    [7449423635] = "Sea 3"
}

local function get_request()
    return (syn and syn.request) or http_request or request or (fluxus and fluxus.request)
end

local serverFruits = {}
local notified = {}

local function send_webhook_embed(fruitList, seaName, jobId)
    local req = get_request()
    if not req then return end

    local embed = {
        embeds = {{
            title = "ðŸ Fruit Spawned!",
            description = "New fruit has spawned in the game!",
            color = 65280, 
            fields = {
                {name = "Fruits", value = fruitList, inline = false},
                {name = "Sea", value = seaName, inline = true},
                {name = "Job ID", value = "```"..jobId.."```", inline = true},
                {name = "Mobile Copy JobId", value = "`"..jobId.."`", inline = false},
            },
            footer = {text = "BloxFruits Notifier"}
        }}
    }

    req({
        Url = WEBHOOK_URL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = HttpService:JSONEncode(embed)
    })
end

local function notify_server(jobId)
    local fruits = serverFruits[jobId]
    if fruits and #fruits > 0 then
        local seaName = SeaNames[game.PlaceId] or "Unknown Sea"
        local fruitList = table.concat(fruits, ", ")

        send_webhook_embed(fruitList, seaName, jobId)

        serverFruits[jobId] = nil
        notified[jobId] = false
    end
end

local function add_fruit(fruitName)
    local jobId = tostring(game.JobId)
    serverFruits[jobId] = serverFruits[jobId] or {}

    for _, f in ipairs(serverFruits[jobId]) do
        if f == fruitName then return end
    end

    table.insert(serverFruits[jobId], fruitName)

    if not notified[jobId] then
        notified[jobId] = true
        task.delay(2, function()
            notify_server(jobId)
        end)
    end
end

function OthersStuffsModule.StartFruitNotifier()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Tool") then
            for _, fruitName in ipairs(FruitsToCheck) do
                if string.find(string.lower(obj.Name), string.lower(fruitName)) then
                    add_fruit(fruitName)
                end
            end
        end
    end

    workspace.ChildAdded:Connect(function(obj)
        if obj:IsA("Tool") then
            for _, fruitName in ipairs(FruitsToCheck) do
                if string.find(string.lower(obj.Name), string.lower(fruitName)) then
                    add_fruit(fruitName)
                end
            end
        end
    end)
end

local RunService = game:GetService("RunService")

local SilentAimPlayersEnabled = false
local playersaimbot = nil
local PlayersPosition = nil
local currentHighlight = nil
local currentTargetType = nil
local AC = {"Soru"}

local maxRange = 1000

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function isAllyWithMe(targetplayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetplayer)
	if not targetplayer or targetplayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetplayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetplayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

local function getClosestplayer(lpHRP)
	if not lpHRP then return nil end
	
	local closest = nil
	local closestDist = math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		if pl ~= player and isEnemy(pl) and pl.Character and pl.Character.Parent ~= nil then
			local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")
			local hrp = getHRP(pl.Character)
			if hum and hum.Health > 0 and hrp then
				local dist = (hrp.Position - lpHRP.Position).Magnitude
				if dist <= maxRange and dist < closestDist then
					closestDist = dist
					closest = pl
				end
			end
		end
	end
	return closest
end

local function applyHighlight(targetModel, targetType)
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if currentHighlight then  
        currentHighlight:Destroy()  
        currentHighlight = nil  
        currentTargetType = nil  
    end  

    local hl = Instance.new("Highlight")  
    hl.FillColor = Color3.fromRGB(255, 255, 0)  
    hl.OutlineColor = Color3.fromRGB(255, 255, 0)  
    hl.FillTransparency = 0.5  
    hl.OutlineTransparency = 0  
    hl.Adornee = targetModel  
    hl.Parent = targetModel  
    currentHighlight = hl  
    currentTargetType = targetType
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
        currentTargetType = nil
    end
end

RunService.RenderStepped:Connect(function()
    local lpChar = player.Character
    if not lpChar then return end
    local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
    if not lpHRP then return end

    local targetModel = nil
    local lookTargetPos = nil

    if SilentAimPlayersEnabled then
		local targetplayer = getClosestplayer(lpHRP)
		if targetplayer and targetplayer ~= player and targetplayer.Character then
			playersaimbot = targetplayer.Name
			local hrp = getHRP(targetplayer.Character)
			lookTargetPos = PlayersPosition
			targetModel = targetplayer.Character
			applyHighlight(targetModel, "player")
		else
			playersaimbot, PlayersPosition = nil, nil
		end
	elseif currentTargetType == "player" then
		playersaimbot, PlayersPosition = nil, nil
		clearHighlight()
	end
end)

spawn(function()
    local ok, hookMeta = pcall(getrawmetatable, game)
    if ok and hookMeta then
        setreadonly(hookMeta, false)

        local OldHook
        OldHook = hookmetamethod(game, "__namecall", function(self, V1, V2, V3, V4, V5, ...)
            local Method = (getnamecallmethod and getnamecallmethod():lower()) or ""

            if tostring(self) == "CommE" and Method == "fireserver" then
                if type(V1) == "string" and table.find(AC, V1) then
                    if typeof(V2) == "CFrame" and typeof(V3) == "CFrame" then
                        if SilentAimPlayersEnabled and PlayersPosition then
                            return OldHook(self, V1, PlayersPosition, PlayersPosition, V4, V5, ...)
                        end
                    end
                end
            end

            return OldHook(self, V1, V2, V3, V4, V5, ...)
        end)

        setreadonly(hookMeta, true)
    end
end)

return OthersStuffsModule
