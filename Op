-- Optimized SilentAimModule (reworked for better performance)
local SilentAimModule = {}

-- ---------- CONFIG / TUNABLES ----------
local SEARCH_INTERVAL = 0.08        -- how often to search for closest target (seconds)
local ORIENT_RATE = 1               -- multiplier (1 = orient every RenderStepped)
local PREDICTION_AMOUNT = 0.1
local MAX_RANGE = 1000

-- ---------- CACHE SERVICES ----------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local remotes = ReplicatedStorage:WaitForChild("Remotes")
local commE = remotes:WaitForChild("CommE")
local MouseModuleInstance = ReplicatedStorage:FindFirstChild("Mouse")
local enemiesFolder = workspace:FindFirstChild("Enemies") -- may be nil; we will re-check occasionally

-- ---------- STATE ----------
local SilentAimPlayersEnabled = false
local SilentAimNPCsEnabled = false
local UserWantsplayerAim = false
local UserWantsNPCAim = false
local PredictionEnabled = false
local HighlightEnabled = false
local AutoKen = false
local ZSkillorM1 = false

local currentTool = nil
local Selectedplayer = nil

local PlayersPosition = nil
local NPCPosition = nil

local currentHighlight = nil
local currentTargetType = nil

local MiniPlayerGui, MiniNpcGui
local MiniPlayerState, MiniNpcState
local MiniPlayerCreated, MiniNpcCreated = false, false

local characterConnections = {}
local Skills = {"X"}

-- ---------- LOCAL HELPERS ----------
local function getHRP(model)
    if not model then return nil end
    return model:FindFirstChild("HumanoidRootPart")
end

local function safeDisconnect(conn)
    if conn and type(conn.Disconnect) == "function" then
        pcall(conn.Disconnect, conn)
    end
end

local function clearConnections()
    for _, conn in ipairs(characterConnections) do
        safeDisconnect(conn)
    end
    characterConnections = {}
end

local function getPredictedPosition(hrp)
    if not hrp then return nil end
    local humanoid = hrp.Parent and hrp.Parent:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return hrp.Position
    end
    if (not PredictionEnabled) or humanoid.WalkSpeed < 5 then
        return hrp.Position
    end
    return hrp.Position + (hrp.Velocity * PREDICTION_AMOUNT)
end

-- ---------- UI MINI TOGGLE (created once) ----------
local function createMiniToggle(name, position, stateVarRef, realVarSetter)
    local playerGui = player:WaitForChild("PlayerGui")
    local guiName = name .. "MiniToggleGuiS"

    -- Reuse existing GUI if present
    local screenGui = playerGui:FindFirstChild(guiName)
    if not screenGui then
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = guiName
        screenGui.ResetOnSpawn = false
        screenGui.Parent = playerGui

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 70, 0, 40)
        button.Position = position
        button.TextScaled = true
        button.TextWrapped = false
        button.TextColor3 = Color3.fromRGB(255,255,255)
        button.BackgroundColor3 = Color3.fromRGB(30,30,30)
        button.BorderSizePixel = 0
        button.Parent = screenGui

        local uicorner = Instance.new("UICorner")
        uicorner.CornerRadius = UDim.new(0,8)
        uicorner.Parent = button

        -- Create a single UIGradient and reuse it (don't destroy/create repeatedly)
        local gradient = Instance.new("UIGradient")
        gradient.Rotation = 45
        gradient.Parent = button
        -- store references
        screenGui.__button = button
        screenGui.__gradient = gradient

        -- Dragging
        local dragging, dragStart, startPos = false, nil, nil
        button.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = button.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        button.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
                local delta = input.Position - dragStart
                button.Position = UDim2.new(
                    0,
                    math.clamp(startPos.X.Offset + delta.X, 0, camera.ViewportSize.X - button.AbsoluteSize.X),
                    0,
                    math.clamp(startPos.Y.Offset + delta.Y, 0, camera.ViewportSize.Y - button.AbsoluteSize.Y)
                )
            end
        end)

        button.MouseButton1Click:Connect(function()
            stateVarRef.value = not stateVarRef.value
            realVarSetter(stateVarRef.value)
            -- update UI
            button.Text = name .. (stateVarRef.value and " ON" or " OFF")
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, stateVarRef.value and Color3.fromRGB(50,200,50) or Color3.fromRGB(255,100,50)),
                ColorSequenceKeypoint.new(1, stateVarRef.value and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,200,50))
            }
        end)
    end

    -- initialize UI text/state when created/used
    local button = screenGui.__button
    local gradient = screenGui.__gradient
    button.Text = name .. (stateVarRef.value and " ON" or " OFF")
    gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, stateVarRef.value and Color3.fromRGB(50,200,50) or Color3.fromRGB(255,100,50)),
        ColorSequenceKeypoint.new(1, stateVarRef.value and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,200,50))
    }

    return screenGui
end

-- ---------- TEAM / ALLY helpers ----------
local function isAllyWithMe(targetplayer)
    if not (player and player:FindFirstChild("PlayerGui")) then return false end
    local myGui = player.PlayerGui
    local main = myGui:FindFirstChild("Main")
    if not main then return false end
    local alliesContainer = main:FindFirstChild("Allies")
    if not alliesContainer then return false end
    local container = alliesContainer:FindFirstChild("Container")
    if not container then return false end
    local alliesFrame = container:FindFirstChild("Allies")
    if not alliesFrame then return false end
    local scrolling = alliesFrame:FindFirstChild("ScrollingFrame")
    if not scrolling then return false end

    for _, frame in ipairs(scrolling:GetDescendants()) do
        if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
            return true
        end
    end
    return false
end

local function isEnemy(targetplayer)
    if not targetplayer or targetplayer == player then return false end
    local myTeam = player.Team
    local targetTeam = targetplayer.Team
    if myTeam and targetTeam then
        -- keep your existing team rules
        if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then return true end
        if myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then return true end
        if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
            if isAllyWithMe(targetplayer) then return false end
            return true
        end
        if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
            return false
        end
    end
    return true
end

-- ---------- SEARCH (rate-limited) ----------
local cachedClosestPlayer = nil
local cachedClosestNPC = nil
do
    local lastSearch = 0
    local function searchLoop()
        while true do
            local now = tick()
            if now - lastSearch >= SEARCH_INTERVAL then
                lastSearch = now

                -- compute closest player
                local lpChar = player.Character
                local lpHRP = lpChar and getHRP(lpChar)
                cachedClosestPlayer = nil
                cachedClosestNPC = nil
                if lpHRP then
                    local closestDist = math.huge
                    for _, pl in ipairs(Players:GetPlayers()) do
                        if pl ~= player and isEnemy(pl) and pl.Character and pl.Character.Parent then
                            local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")
                            local hrp = getHRP(pl.Character)
                            if hum and hum.Health > 0 and hrp then
                                local dist = (hrp.Position - lpHRP.Position).Magnitude
                                if dist <= MAX_RANGE and dist < closestDist then
                                    closestDist = dist
                                    cachedClosestPlayer = pl
                                end
                            end
                        end
                    end

                    -- compute closest NPC (if the folder exists)
                    enemiesFolder = enemiesFolder or workspace:FindFirstChild("Enemies")
                    if enemiesFolder then
                        local cDist = math.huge
                        for _, npc in ipairs(enemiesFolder:GetChildren()) do
                            if npc:IsA("Model") then
                                local hum = npc:FindFirstChildWhichIsA("Humanoid")
                                local hrp = getHRP(npc)
                                if hum and hum.Health > 0 and hrp then
                                    local dist = (hrp.Position - lpHRP.Position).Magnitude
                                    if dist <= MAX_RANGE and dist < cDist then
                                        cDist = dist
                                        cachedClosestNPC = npc
                                    end
                                end
                            end
                        end
                    end
                end
            end
            task.wait(SEARCH_INTERVAL * 0.5) -- small sleep to avoid tight loop
        end
    end
    task.spawn(searchLoop)
end

-- ---------- HIGHLIGHT (reuse single highlight instance) ----------
local function applyHighlight(targetModel, targetType)
    if not HighlightEnabled then return end
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if not currentHighlight or not currentHighlight.Parent then
        currentHighlight = Instance.new("Highlight")
        currentHighlight.Parent = workspace -- parent to workspace for safety
        currentHighlight.FillTransparency = 0.5
        currentHighlight.OutlineTransparency = 0
        currentHighlight.FillColor = Color3.fromRGB(255,255,0)
        currentHighlight.OutlineColor = Color3.fromRGB(255,255,0)
    end
    currentHighlight.Adornee = targetModel
    currentTargetType = targetType
    -- keep VSkillModule call minimal (only if present)
    pcall(function()
        if _G and _G.VSkillModule and type(_G.VSkillModule.CheckVSkillUsage) == "function" then
            _G.VSkillModule:CheckVSkillUsage(SilentAimModule)
        end
    end)
end

local function clearHighlight()
    if currentHighlight then
        -- simply clear adornee (keep instance to reuse)
        currentHighlight.Adornee = nil
        currentTargetType = nil
    end
end

-- ---------- TOOL HOOK (keep simple) ----------
local function hookTool(tool)
    currentTool = tool
    table.insert(characterConnections, tool.AncestryChanged:Connect(function(_, parent)
        if not parent then currentTool = nil end
    end))
end

local function onCharacterAdded(char)
    clearConnections()
    table.insert(characterConnections, char.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then hookTool(child) end
    end))
    table.insert(characterConnections, char.ChildRemoved:Connect(function(child)
        if child == currentTool then currentTool = nil end
    end))
end

player.CharacterAdded:Connect(onCharacterAdded)
if player.Character then onCharacterAdded(player.Character) end

-- ---------- ORIENTATION (RenderStepped, but very light) ----------
local orientAccumulator = 0
RunService.RenderStepped:Connect(function(dt)
    -- small early outs
    local lpChar = player.Character
    local lpHRP = lpChar and getHRP(lpChar)
    if not lpHRP then return end

    orientAccumulator = orientAccumulator + dt * ORIENT_RATE
    if orientAccumulator < 1/60 then
        -- not necessary to run every tiny fraction; this simple limiter helps on low-end
        return
    end
    orientAccumulator = 0

    local lookTargetPos = nil
    local targetModel = nil

    -- use cached search results
    if SilentAimPlayersEnabled then
        local targetplayer = Selectedplayer or cachedClosestPlayer
        if targetplayer and targetplayer ~= player and targetplayer.Character then
            local hrp = getHRP(targetplayer.Character)
            if hrp then
                PlayersPosition = getPredictedPosition(hrp)
                lookTargetPos = PlayersPosition
                targetModel = targetplayer.Character
                applyHighlight(targetModel, "player")
            end
        else
            PlayersPosition = nil
            if currentTargetType == "player" then clearHighlight() end
        end
    elseif currentTargetType == "player" then
        PlayersPosition = nil
        clearHighlight()
    end

    if SilentAimNPCsEnabled then
        local closestNPC = cachedClosestNPC
        if closestNPC then
            local hrp = getHRP(closestNPC)
            if hrp then
                NPCPosition = getPredictedPosition(hrp)
                lookTargetPos = lookTargetPos or NPCPosition
                targetModel = targetModel or closestNPC
                applyHighlight(targetModel, "NPC")
            end
        else
            NPCPosition = nil
            if currentTargetType == "NPC" then clearHighlight() end
        end
    elseif currentTargetType == "NPC" then
        NPCPosition = nil
        clearHighlight()
    end

    -- orient player when using a tool and skill ready
    if currentTool and lookTargetPos and (currentTool.Name ~= "Dough-Dough") then
        -- check skill readiness lightly (avoid heavy Find calls in hot path)
        local okToOrient = false
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui then
            local main = playerGui:FindFirstChild("Main")
            local skillsFolder = main and main:FindFirstChild("Skills")
            if skillsFolder then
                local toolFrame = skillsFolder:FindFirstChild(currentTool.Name)
                if toolFrame then
                    -- minimal check: presence of frames Z/X/C/V with Cooldown children
                    okToOrient = false
                    for _, key in ipairs({"Z","X","C","V"}) do
                        local sk = toolFrame:FindFirstChild(key)
                        if sk and sk:FindFirstChild("Cooldown") and sk.Cooldown:IsA("Frame") then
                            if sk.Cooldown.Size.X.Scale == 1.0 then
                                okToOrient = true
                                break
                            end
                        end
                    end
                end
            end
        end

        if okToOrient then
            local lookVector = (Vector3.new(lookTargetPos.X, lpHRP.Position.Y, lookTargetPos.Z) - lpHRP.Position)
            if lookVector.Magnitude > 0.001 then
                lpHRP.CFrame = CFrame.new(lpHRP.Position, lpHRP.Position + lookVector.Unit)
            end
        end
    end
end)

-- ---------- MOUSE PATCH (use RenderStepped or small loop; avoid Heartbeat) ----------
-- keep this minimal: only run when conditions are true
do
    local MouseTable = nil
    if MouseModuleInstance then
        local ok, result = pcall(require, MouseModuleInstance)
        if ok and type(result) == "table" then
            MouseTable = result
        end
    end

    -- Use RenderStepped to update Mouse target for responsiveness (cheap)
    RunService.RenderStepped:Connect(function()
        if MouseTable and ZSkillorM1 and (SilentAimPlayersEnabled or SilentAimNPCsEnabled) then
            local targetCFrame = nil
            if PlayersPosition then targetCFrame = CFrame.new(PlayersPosition) end
            if (not targetCFrame) and NPCPosition then targetCFrame = CFrame.new(NPCPosition) end
            if targetCFrame then
                pcall(function()
                    MouseTable.Hit = targetCFrame
                    MouseTable.Target = nil
                end)
            end
        end
    end)
end

-- ---------- HOOK METAMETHOD (kept but minimal checks) ----------
do
    local ok, meta = pcall(getrawmetatable, game)
    if ok and meta then
        setreadonly(meta, false)
        local oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod and getnamecallmethod():lower() or ""
            local args = {...}

            -- fast-path: only do special behavior for RemoteEvent:FireServer and RemoteFunction:InvokeServer
            if tostring(self) == "RemoteEvent" and method == "fireserver" then
                local v1 = args[1]
                if typeof(v1) == "Vector3" then
                    if SilentAimPlayersEnabled and PlayersPosition then
                        return oldNamecall(self, PlayersPosition, select(2, ...))
                    elseif SilentAimNPCsEnabled and NPCPosition then
                        return oldNamecall(self, NPCPosition, select(2, ...))
                    end
                end
            elseif method == "invokeserver" then
                local v1 = args[1]
                -- Check very fast conditions to avoid heavy checks each invoke
                if type(v1) == "string" and table.find(Skills, v1) then
                    if SilentAimPlayersEnabled and PlayersPosition then
                        return oldNamecall(self, v1, PlayersPosition, nil, select(4, ...))
                    elseif SilentAimNPCsEnabled and NPCPosition then
                        return oldNamecall(self, v1, NPCPosition, nil, select(4, ...))
                    end
                end
            end

            return oldNamecall(self, ...)
        end)
        setreadonly(meta, true)
    end
end

-- ---------- MISC: AutoKen (light loop) ----------
task.spawn(function()
    while true do
        local char = player.Character or player.CharacterAdded:Wait()
        if not char then task.wait(0.5) end
        char:WaitForChild("Humanoid")
        char:WaitForChild("HumanoidRootPart")
        task.wait(0.1)

        if AutoKen then
            if CollectionService:HasTag(char, "Ken") then
                local pg = player:FindFirstChild("PlayerGui")
                if pg then
                    local kenButton = pg:FindFirstChild("MobileContextButtons") and pg.MobileContextButtons:FindFirstChild("ContextButtonFrame") and pg.MobileContextButtons.ContextButtonFrame:FindFirstChild("BoundActionKen")
                    if kenButton and kenButton:GetAttribute("Selected") ~= true then
                        kenButton:SetAttribute("Selected", true)
                    end
                end
                local observationManager = getrenv()._G and getrenv()._G.OM
                if observationManager and not observationManager.active then
                    observationManager.radius = 0
                    observationManager:setActive(true)
                    pcall(function() commE:FireServer("Ken", true) end)
                end
            end
            task.wait(0.5)
        else
            task.wait(0.5)
        end
    end
end)

-- ---------- KEYBINDS ----------
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.G then
        -- toggle player / npc mini guis if created
        if MiniPlayerCreated and MiniPlayerGui then
            if MiniPlayerState then
                MiniPlayerState.value = not MiniPlayerState.value
                SilentAimPlayersEnabled = MiniPlayerState.value
                UserWantsplayerAim = MiniPlayerState.value
                local btn = MiniPlayerGui:FindFirstChildWhichIsA("TextButton", true)
                if btn then
                    btn.Text = "Player" .. (MiniPlayerState.value and " ON" or " OFF")
                    local grad = btn:FindFirstChildOfClass("UIGradient")
                    if grad then
                        grad.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, MiniPlayerState.value and Color3.fromRGB(50,200,50) or Color3.fromRGB(255,100,50)),
                            ColorSequenceKeypoint.new(1, MiniPlayerState.value and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,200,50))
                        }
                    end
                end
            end
        end

        if MiniNpcCreated and MiniNpcGui then
            if MiniNpcState then
                MiniNpcState.value = not MiniNpcState.value
                SilentAimNPCsEnabled = MiniNpcState.value
                UserWantsNPCAim = MiniNpcState.value
                local btn = MiniNpcGui:FindFirstChildWhichIsA("TextButton", true)
                if btn then
                    btn.Text = "NPC" .. (MiniNpcState.value and " ON" or " OFF")
                    local grad = btn:FindFirstChildOfClass("UIGradient")
                    if grad then
                        grad.Color = ColorSequence.new{
                            ColorSequenceKeypoint.new(0, MiniNpcState.value and Color3.fromRGB(50,200,50) or Color3.fromRGB(255,100,50)),
                            ColorSequenceKeypoint.new(1, MiniNpcState.value and Color3.fromRGB(50,255,50) or Color3.fromRGB(255,200,50))
                        }
                    end
                end
            end
        end
    end
end)

-- ---------- PUBLIC API ----------
function SilentAimModule:SetAutoKen(state) AutoKen = state end
function SilentAimModule:SetZSkillorM1(state) ZSkillorM1 = state end
function SilentAimModule:Pause() SilentAimPlayersEnabled = false SilentAimNPCsEnabled = false end
function SilentAimModule:Restore() SilentAimPlayersEnabled = UserWantsplayerAim SilentAimNPCsEnabled = UserWantsNPCAim end
function SilentAimModule:IsplayerAimEnabled() return SilentAimPlayersEnabled end
function SilentAimModule:IsNPCAimEnabled() return SilentAimNPCsEnabled end
function SilentAimModule:SetDistanceLimit(num) if typeof(num) == "number" then MAX_RANGE = num end end
function SilentAimModule:SetSelectedPlayer(playerName)
    if not playerName or playerName == "" then Selectedplayer = nil return end
    local found = Players:FindFirstChild(playerName)
    if found then Selectedplayer = found end
end
function SilentAimModule:GetSelectedPlayer() return Selectedplayer and Selectedplayer.Name or "None" end
function SilentAimModule:SetPrediction(state) PredictionEnabled = state end
function SilentAimModule:SetHighlight(state) HighlightEnabled = state if not state then clearHighlight() end end
function SilentAimModule:IsHighlightEnabled() return HighlightEnabled end
function SilentAimModule:SetPredictionAmount(num) if typeof(num) == "number" then PREDICTION_AMOUNT = num end end

function SilentAimModule:SetPlayerSilentAim(state)
    UserWantsplayerAim = state
    SilentAimPlayersEnabled = state
    if not MiniPlayerCreated and state then
        MiniPlayerState = { value = SilentAimPlayersEnabled }
        MiniPlayerGui = createMiniToggle("Player", UDim2.new(0,10,0,90), MiniPlayerState, function(val) SilentAimPlayersEnabled = val UserWantsplayerAim = val end)
        MiniPlayerCreated = true
    elseif MiniPlayerCreated then
        if MiniPlayerGui then MiniPlayerGui.Enabled = state end
        if MiniPlayerState then MiniPlayerState.value = SilentAimPlayersEnabled end
    end
end

function SilentAimModule:SetNPCSilentAim(state)
    UserWantsNPCAim = state
    SilentAimNPCsEnabled = state
    if not MiniNpcCreated and state then
        MiniNpcState = { value = SilentAimNPCsEnabled }
        MiniNpcGui = createMiniToggle("NPC", UDim2.new(0,10,0,50), MiniNpcState, function(val) SilentAimNPCsEnabled = val UserWantsNPCAim = val end)
        MiniNpcCreated = true
    elseif MiniNpcCreated then
        if MiniNpcGui then MiniNpcGui.Enabled = state end
        if MiniNpcState then MiniNpcState.value = SilentAimNPCsEnabled end
    end
end

return SilentAimModule
