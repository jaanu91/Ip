local SilentAimModule = {}

local VSkillModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/jaanu91/Ip/refs/heads/main/Kata"))()

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local SkillsFolder = PlayerGui:WaitForChild("Main"):WaitForChild("Skills")
local Character = player.Character or player.CharacterAdded:Wait()
local UserInputService = game:GetService("UserInputService")  
local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local RS = game:GetService("ReplicatedStorage")
local MouseModule = RS:FindFirstChild("Mouse")
local commE = RS:WaitForChild("Remotes"):WaitForChild("CommE")

local Services = setmetatable({}, {
    __index = function(self, serviceName)
        local good, service = pcall(game.GetService, game, serviceName);
        if (good) then
            self[serviceName] = service
            return service;
        end
    end
});

local SilentAimPlayersEnabled = false
local SilentAimNPCsEnabled = false
local UserWantsplayerAim = false
local UserWantsNPCAim = false
local PredictionEnabled = false
local AutoKen = false

local playersaimbot = nil
local PlayersPosition = nil
local NPCaimbot = nil
local NPCPosition = nil
local currentHighlight = nil
local currentTargetType = nil
local Selectedplayer = nil

local Skills = {"Z", "X", "C", "V", "F"}
local ActiveSkills = {}
local characterConnections = {}

local PredictionAmount = 0.1
local maxRange = 1000

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function getPredictedPosition(hrp)
	if not hrp then return nil end

	local humanoid = hrp.Parent:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return hrp.Position
	end

	if not PredictionEnabled or humanoid.WalkSpeed < 5 then
		return hrp.Position
	end

	return hrp.Position + (hrp.Velocity * PredictionAmount)
end

local function clearConnections()
	for _, conn in ipairs(characterConnections) do
		pcall(function() conn:Disconnect() end)
	end
	characterConnections = {}
end

-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetplayer)
	local myGui = player:FindFirstChild("PlayerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetplayer)
	if not targetplayer or targetplayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetplayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetplayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

local function getClosestplayer(lpHRP)
	if not lpHRP then return nil end
	
	local closest = nil
	local closestDist = math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		if pl ~= player and isEnemy(pl) and pl.Character and pl.Character.Parent ~= nil then
			local hum = pl.Character:FindFirstChildWhichIsA("Humanoid")
			local hrp = getHRP(pl.Character)
			if hum and hum.Health > 0 and hrp then
				local dist = (hrp.Position - lpHRP.Position).Magnitude
				if dist <= maxRange and dist < closestDist then
					closestDist = dist
					closest = pl
				end
			end
		end
	end
	return closest
end

local function getClosestNPC(lpHRP)
    if not lpHRP then return nil end

    local enemiesFolder = workspace:FindFirstChild("Enemies")
    if not enemiesFolder then return nil end

    local closest = nil
    local closestDist = math.huge
    for _, npc in ipairs(enemiesFolder:GetChildren()) do
        if npc:IsA("Model") then
            local hum = npc:FindFirstChildWhichIsA("Humanoid")
            local hrp = getHRP(npc)
            if hum and hum.Health > 0 and hrp then
                local dist = (hrp.Position - lpHRP.Position).Magnitude
                if dist <= maxRange and dist < closestDist then
                    closestDist = dist
                    closest = npc
                end
            end
        end
    end
    return closest
end

local function applyHighlight(targetModel, targetType)
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if currentHighlight then  
        currentHighlight:Destroy()  
        currentHighlight = nil  
        currentTargetType = nil  
    end  

    local hl = Instance.new("Highlight")  
    hl.FillColor = Color3.fromRGB(255, 255, 0)  
    hl.OutlineColor = Color3.fromRGB(255, 255, 0)  
    hl.FillTransparency = 0.5  
    hl.OutlineTransparency = 0  
    hl.Adornee = targetModel  
    hl.Parent = targetModel  
    currentHighlight = hl  
    currentTargetType = targetType

    VSkillModule:CheckVSkillUsage(SilentAimModule)
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
        currentTargetType = nil
    end
end

RunService.Heartbeat:Connect(function()
    local lpChar = player.Character
    if not lpChar then return end
    local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
    if not lpHRP then return end

    local targetModel = nil

    if SilentAimPlayersEnabled then
		local targetplayer = Selectedplayer or getClosestplayer(lpHRP)
		if targetplayer and targetplayer ~= player and targetplayer.Character then
			playersaimbot = targetplayer.Name
			local hrp = getHRP(targetplayer.Character)
			PlayersPosition = getPredictedPosition(hrp)
			targetModel = targetplayer.Character
			applyHighlight(targetModel, "player")
		else
			playersaimbot, PlayersPosition = nil, nil
		end
	elseif currentTargetType == "player" then
		playersaimbot, PlayersPosition = nil, nil
		clearHighlight()
	end

	if SilentAimNPCsEnabled then  
	    local closestNPC = getClosestNPC(lpHRP)  
	    if closestNPC then  
	        NPCaimbot = closestNPC.Name  
	        local hrp = getHRP(closestNPC)  
	        NPCPosition = getPredictedPosition(hrp)  
	        if not targetModel then  
	            targetModel = closestNPC  
	            applyHighlight(targetModel, "NPC")  
	        end  
	    else  
	        NPCaimbot, NPCPosition = nil, nil  
	    end  
	elseif currentTargetType == "NPC" then
	    NPCaimbot, NPCPosition = nil, nil  
	    clearHighlight()
	end
end)

spawn(function()
    local ok, hookMeta = pcall(getrawmetatable, game)
    if ok and hookMeta then
        setreadonly(hookMeta, false)
        local OldHook
        OldHook = hookmetamethod(game, "__namecall", function(self, V1, V2, ...)
            local Method = (getnamecallmethod and getnamecallmethod():lower()) or ""

            if tostring(self) == "RemoteEvent" and Method == "fireserver" then
                if typeof(V1) == "Vector3" then
                    if SilentAimPlayersEnabled and PlayersPosition then
                        return OldHook(self, PlayersPosition, V2, ...)
                    elseif SilentAimNPCsEnabled and NPCPosition then
                        return OldHook(self, NPCPosition, V2, ...)
                    end
                end
            elseif Method == "invokeserver" then
	            if type(V1) == "string" and table.find(Skills, V1) then  
	                if ActiveSkills[V1] then
	                    if SilentAimPlayersEnabled and PlayersPosition then
	                        return OldHook(self, V1, PlayersPosition, nil, ...)
	                    elseif SilentAimNPCsEnabled and NPCPosition then
	                        return OldHook(self, V1, NPCPosition, nil, ...)
	                    end
					end
	            end
			end
            
            UserInputService.InputBegan:Connect(function(input, gameProcessed)  
                if gameProcessed then return end  
                if table.find(Skills, input.KeyCode.Name) then  
                    ActiveSkills[input.KeyCode.Name] = true
                end  
            end)  

            UserInputService.InputEnded:Connect(function(input, gameProcessed)  
                if gameProcessed then return end  
                if table.find(Skills, input.KeyCode.Name) then  
                    ActiveSkills[input.KeyCode.Name] = false
                end  
            end)
            
            local function connectSkillButton(button, keyName)
			if not button then return end
	
			button.InputBegan:Connect(function(input, gameProcessed)
				if gameProcessed then return end  
				if table.find(Skills, input.keyName) then  
					ActiveSkills[input.keyName] = true
				end
			end)
	
			button.InputEnded:Connect(function(input, gameProcessed)
				if gameProcessed then return end  
				if table.find(Skills, input.keyName) then  
					ActiveSkills[input.keyName] = false
				end
			end)

			local function scanSkills()
				for _, toolFolder in pairs(SkillsFolder:GetChildren()) do
					for _, key in ipairs(Skills) do
						local frame = toolFolder:FindFirstChild(key)
						if frame and frame:FindFirstChild("Mobile") then
							local button = frame.Mobile
							if not button:GetAttribute("Connected") then
								connectSkillButton(button, key)
								button:SetAttribute("Connected", true)
							end
						end
					end
				end
			end

			SkillsFolder.ChildAdded:Connect(function(child)
				task.wait(0.2)
				scanSkills()
			end)

			scanSkills()
                
            return OldHook(self, V1, V2, ...)
        end)
        setreadonly(hookMeta, true)
    end
end)

if MouseModule and typeof(MouseModule) == "Instance" then
    local ok2, Mouse = pcall(function() return require(MouseModule) end)
    if ok2 and Mouse then
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        if RootPart then
            pcall(function()
                Mouse.Hit = CFrame.new(RootPart.Position)
                Mouse.Target = RootPart
            end)
        else
            task.spawn(function()
                local RootPart = Character:WaitForChild("HumanoidRootPart")
                pcall(function()
                    Mouse.Hit = CFrame.new(RootPart.Position)
                    Mouse.Target = RootPart
                end)
            end)
        end

        RunService.Heartbeat:Connect(function()
            if Mouse then
                if NPCPosition then
                    pcall(function() Mouse.Hit = CFrame.new(NPCPosition) end)
                elseif PlayersPosition then
                    pcall(function() Mouse.Hit = CFrame.new(PlayersPosition) end)
                end
            end
        end)
    end
end

local HasTag = function(tagName)
  local char = player.Character
  if (not char) then return false; end
  return Services.CollectionService:HasTag(char, tagName);
end

task.spawn(function()
	while true do
		local char = player.Character or player.CharacterAdded:Wait();
		char:WaitForChild("Humanoid");
		char:WaitForChild("HumanoidRootPart");
		wait(.1);
		if AutoKen then
		    if HasTag("Ken") then
				local playerGui = player:FindFirstChild("PlayerGui")
		        if playerGui then
		            local kenButton = playerGui:FindFirstChild("MobileContextButtons")
	                and playerGui.MobileContextButtons:FindFirstChild("ContextButtonFrame")
	                and playerGui.MobileContextButtons.ContextButtonFrame:FindFirstChild("BoundActionKen")

		            if kenButton and kenButton:GetAttribute("Selected") ~= true then
		                kenButton:SetAttribute("Selected", true)
		            end
		        end
		
		        local observationManager = getrenv()._G.OM;
		        if (observationManager and not observationManager.active) then
					observationManager.radius = 0
		            observationManager:setActive(true);
		            commE:FireServer("Ken", true);
		        end
		    end
		    wait();
		end
	end
end);

function SilentAimModule:SetAutoKen(state)
	AutoKen = state
end

function SilentAimModule:SetPlayerSilentAim(state)
	UserWantsplayerAim = state
	SilentAimPlayersEnabled = state
end

function SilentAimModule:SetNPCSilentAim(state)
	UserWantsNPCAim = state
	SilentAimNPCsEnabled = state
end

function SilentAimModule:Pause()
    SilentAimPlayersEnabled = false
    SilentAimNPCsEnabled = false
end

function SilentAimModule:Restore()
    SilentAimPlayersEnabled = UserWantsplayerAim
    SilentAimNPCsEnabled = UserWantsNPCAim
end

function SilentAimModule:IsplayerAimEnabled()
    return SilentAimPlayersEnabled
end

function SilentAimModule:IsNPCAimEnabled()
    return SilentAimNPCsEnabled
end

function SilentAimModule:SetDistanceLimit(num)
	if typeof(num) == "number" then
		maxRange = num
	end
end

function SilentAimModule:SetSelectedPlayer(playerName)
	if not playerName or playerName == "" then
		Selectedplayer = nil
		return
	end

	local found = Players:FindFirstChild(playerName)
	if found then
		Selectedplayer = found
	end
end

function SilentAimModule:GetSelectedPlayer()
	return Selectedplayer and Selectedplayer.Name or "None"
end

function SilentAimModule:SetPrediction(state)
	PredictionEnabled = state
end

function SilentAimModule:SetPredictionAmount(num)
	if typeof(num) == "number" then
		PredictionAmount = num
	end
end

return SilentAimModule
