local SilentAimModule = {}

Playersaimbot = nil
PlayersPosition = nil
NPCaimbot = nil
NPCPosition = nil

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local camera = workspace.CurrentCamera

local SilentAimPlayersEnabled = false
local SilentAimNPCsEnabled = false
local PredictionEnabled = false
local savedSilentPlayers = false
local savedSilentNPCs = false
local vActive, sharkZActive, cursedZActive = false, false, false

local dmgConn = nil
local currentTool = nil

local PredictionAmount = 0.1
local maxRange = 1000
local rightTouches = {}

local function disableSilentAimTemp()
    if SilentAimPlayersEnabled or SilentAimNPCsEnabled then
        savedSilentPlayers = SilentAimPlayersEnabled
        savedSilentNPCs = SilentAimNPCsEnabled
        SilentAimModule:SetPlayerSilentAim(false)
        SilentAimModule:SetNPCSilentAim(false)
    end
end

local function restoreSilentAim()
    SilentAimModule:SetPlayerSilentAim(savedSilentPlayers)
    SilentAimModule:SetNPCSilentAim(savedSilentNPCs)
    savedSilentPlayers, savedSilentNPCs = false, false
end

local currentHighlight = nil
local function applyHighlight(targetModel)
	if not targetModel then return end
	if currentHighlight and currentHighlight.Adornee == targetModel then return end

	if currentHighlight then
		currentHighlight:Destroy()
		currentHighlight = nil
	end

	local hl = Instance.new("Highlight")
	hl.FillColor = Color3.fromRGB(255, 255, 0)
	hl.OutlineColor = Color3.fromRGB(255, 255, 0)
	hl.FillTransparency = 0.5
	hl.OutlineTransparency = 0
	hl.Adornee = targetModel
	hl.Parent = targetModel
	currentHighlight = hl
end

local function clearHighlight()
	if currentHighlight then
		currentHighlight:Destroy()
		currentHighlight = nil
	end
end

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function getPredictedPosition(hrp)
	if not hrp then return nil end
	if not PredictionEnabled then
		return hrp.Position
	end
	return hrp.Position + (hrp.Velocity * PredictionAmount)
end

local function getClosestPlayer(lpHRP)
	local closest = nil
	local closestDist = math.huge
	for _, pl in ipairs(Players:GetPlayers()) do
		if pl ~= player and pl.Character and pl.Character.Parent ~= nil then
			local hum = pl.Character:FindFirstChildOfClass("Humanoid")
			local hrp = getHRP(pl.Character)
			if hum and hum.Health > 0 and hrp then
				local dist = (hrp.Position - lpHRP.Position).Magnitude
				if dist <= maxRange and dist < closestDist then
					closestDist = dist
					closest = pl
				end
			end
		end
	end
	return closest
end

local function getClosestNPC(lpHRP)
	local enemiesFolder = workspace:FindFirstChild("Enemies")
	if not enemiesFolder then return nil end

	local closest = nil
	local closestDist = math.huge
	for _, npc in ipairs(enemiesFolder:GetChildren()) do
		if npc:IsA("Model") and npc:FindFirstChild("Humanoid") then
			local hum = npc:FindFirstChild("Humanoid")
			local hrp = getHRP(npc)
			if hum and hum.Health > 0 and hrp then
				local dist = (hrp.Position - lpHRP.Position).Magnitude
				if dist <= maxRange and dist < closestDist then
					closestDist = dist
					closest = npc
				end
			end
		end
	end
	return closest
end

RunService.Heartbeat:Connect(function()
	local lpChar = player.Character
	if not lpChar then return end
	local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
	if not lpHRP then return end

	local targetModel = nil

	if SilentAimPlayersEnabled then
		local closestPl = getClosestPlayer(lpHRP)
		if closestPl then
			Playersaimbot = closestPl.Name
			local hrp = getHRP(closestPl.Character)
			PlayersPosition = getPredictedPosition(hrp)
			targetModel = closestPl.Character
		else
			Playersaimbot, PlayersPosition = nil, nil
		end
	else
		Playersaimbot, PlayersPosition = nil, nil
	end

	if SilentAimNPCsEnabled and not targetModel then
		local closestNPC = getClosestNPC(lpHRP)
		if closestNPC then
			NPCaimbot = closestNPC.Name
			local hrp = getHRP(closestNPC)
			NPCPosition = getPredictedPosition(hrp)
			targetModel = closestNPC
		else
			NPCaimbot, NPCPosition = nil, nil
		end
	else
		NPCaimbot, NPCPosition = nil, nil
	end

	if SilentAimPlayersEnabled or SilentAimNPCsEnabled then
		if targetModel then
			applyHighlight(targetModel)
		else
			clearHighlight()
		end
	else
		clearHighlight()
	end
end)

local function checkSkillStopCondition()
    if currentHighlight then
        if sharkZActive or cursedZActive or vActive then
            disableSilentAimTemp()
            return true
        end
    end
    return false
end

local function watchDamageCounter()
    if dmgConn then
        pcall(function() dmgConn:Disconnect() end)
        dmgConn = nil
    end

    local ok, dmgTextLabel = pcall(function()
        return player:WaitForChild("PlayerGui"):WaitForChild("Main"):WaitForChild("DmgCounter"):WaitForChild("Text")
    end)
    if not ok or not dmgTextLabel then return end

    dmgConn = dmgTextLabel:GetPropertyChangedSignal("Text"):Connect(function()
        local dmgText = tonumber(dmgTextLabel.Text) or 0
        if dmgText > 0 then
		    checkSkillStopCondition()
		end
    end)
end

UserInputService.TouchStarted:Connect(function(touch)
    if touch.Position.X > camera.ViewportSize.X / 2 then
        rightTouches[touch] = true
        watchDamageCounter()
    end
end)

UserInputService.TouchEnded:Connect(function(touch)
    if rightTouches[touch] then
        rightTouches[touch] = nil
        if not next(rightTouches) then
            vActive = false
            sharkZActive = false
            cursedZActive = false
            restoreSilentAim()
        end
    end
end)

local function hookTool(tool)
	currentTool = tool
	tool.AncestryChanged:Connect(function(_, parent)
		if not parent then
			currentTool = nil
			vActive = false
			sharkZActive = false
			cursedZActive = false
		end
	end)
end

char.ChildAdded:Connect(function(child)
	if child:IsA("Tool") then
		hookTool(child)
	end
end)

char.ChildRemoved:Connect(function(child)
	if child == currentTool then
		currentTool = nil
		vActive = false
		sharkZActive = false
		cursedZActive = false
	end
end)

local old
old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}

    if (method == "InvokeServer" or method == "FireServer") then
        local a1 = args[1]

        if typeof(a1) == "string" and a1:upper() == "V" then
            if currentTool and currentTool.Name == "Dough-Dough" then
                vActive = true
            end
        end

        if typeof(a1) == "string" and a1:upper() == "Z" then
            if currentTool and currentTool.Name == "Shark Anchor" then
                sharkZActive = true
            elseif currentTool and currentTool.Name == "Cursed Dual Katana" then
                cursedZActive = true
            end
        end

        if currentTool and currentTool.Name == "Shark Anchor" and self.Name == "EquipEvent" then
            if args[1] == false then
                currentTool = nil
                sharkZActive = false
                restoreSilentAim()
            end
        end
    end
    return old(self, ...)
end)

spawn(function()
	local success, gg = pcall(function() return getrawmetatable(game) end)
	if not success or not gg then return end
	local old = gg.__namecall
	if not old then return end

	setreadonly(gg, false)
	gg.__namecall = newcclosure(function(...)
		local method = getnamecallmethod()
		local args = {...}

		local targetPos = nil
		if SilentAimPlayersEnabled and PlayersPosition then
			targetPos = PlayersPosition
		elseif SilentAimNPCsEnabled and NPCPosition then
			targetPos = NPCPosition
		end

		if targetPos and tostring(method) == "FireServer" then
			if tostring(args[1]) == "RemoteEvent" then
				if tostring(args[2]) ~= "true" and tostring(args[2]) ~= "false" then
					args[2] = targetPos
					return old(unpack(args))
				end
			end
		end
		return old(...)
	end)
	setreadonly(gg, true)
end)

function SilentAimModule:SetPlayerSilentAim(state)
	SilentAimPlayersEnabled = state
end

function SilentAimModule:SetNPCSilentAim(state)
	SilentAimNPCsEnabled = state
end

function SilentAimModule:SetDistanceLimit(num)
	if typeof(num) == "number" then
		maxRange = num
	end
end

function SilentAimModule:SetPrediction(state)
	PredictionEnabled = state
end

function SilentAimModule:SetPredictionAmount(num)
	if typeof(num) == "number" then
		PredictionAmount = num
	end
end

return SilentAimModule
