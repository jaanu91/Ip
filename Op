local SilentAimModule = {}

local VSkillModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/jaanu91/Ip/refs/heads/main/Kata"))()

local players = game:GetService("players")
local RunService = game:GetService("RunService")

local player = players.Localplayer
local char = player.char or player.charAdded:Wait()
local camera = workspace.CurrentCamera
local RS = game:GetService("RS")
local commE = RS:WaitForChild("Remotes"):WaitForChild("CommE")

local Services = setmetatable({}, {
    __index = function(self, serviceName)
        local good, service = pcall(game.GetService, game, serviceName);
        if (good) then
            self[serviceName] = service
            return service;
        end
    end
});

local SilentAimplayersEnabled = false
local SilentAimNPCsEnabled = false
local UserWantsplayerAim = false
local UserWantsNPCAim = false
local PredictionEnabled = false
local AutoKen = false
local Skills = {"Z", "X", "C", "V", "F"}

local playersaimbot = nil
local playersPosition = nil
local NPCaimbot = nil
local NPCPosition = nil
local currentHighlight = nil
local currentTargetType = nil
local Selectedplayer = nil

local PredictionAmount = 0.1
local maxRange = 1000

local function getHRP(model)
	if not model or not model:FindFirstChild("HumanoidRootPart") then return nil end
	return model.HumanoidRootPart
end

local function getPredictedPosition(hrp)
	if not hrp then return nil end
	if not PredictionEnabled then
		return hrp.Position
	end
	return hrp.Position + (hrp.Velocity * PredictionAmount)
end

-- =========================
-- Team Check
-- =========================
local function isAllyWithMe(targetplayer)
	local myGui = player:FindFirstChild("playerGui")
	if not myGui then return false end

	local scrolling = myGui:FindFirstChild("Main")
		and myGui.Main:FindFirstChild("Allies")
		and myGui.Main.Allies:FindFirstChild("Container")
		and myGui.Main.Allies.Container:FindFirstChild("Allies")
		and myGui.Main.Allies.Container.Allies:FindFirstChild("ScrollingFrame")

	if scrolling then
		for _, frame in pairs(scrolling:GetDescendants()) do
			if frame:IsA("ImageButton") and frame.Name == targetplayer.Name then
				return true
			end
		end
	end

	return false
end

local function isEnemy(targetplayer)
	if not targetplayer or targetplayer == player then
		return false
	end

	local myTeam = player.Team
	local targetTeam = targetplayer.Team

	if myTeam and targetTeam then
		if myTeam.Name == "Pirates" and targetTeam.Name == "Marines" then
			return true
		elseif myTeam.Name == "Marines" and targetTeam.Name == "Pirates" then
			return true
		end

		if myTeam.Name == "Pirates" and targetTeam.Name == "Pirates" then
			if isAllyWithMe(targetplayer) then
				return false -- ally, not enemy
			end
			return true
		end

		if myTeam.Name == "Marines" and targetTeam.Name == "Marines" then
			return false
		end
	end

	return true
end

local function getClosestplayer(lpHRP)
	if not lpHRP then return nil end
	
	local closest = nil
	local closestDist = math.huge
	for _, pl in ipairs(players:Getplayers()) do
		if pl ~= player and isEnemy(pl) and pl.char and pl.char.Parent ~= nil then
			local hum = pl.char:FindFirstChildWhichIsA("Humanoid")
			local hrp = getHRP(pl.char)
			if hum and hum.Health > 0 and hrp then
				local dist = (hrp.Position - lpHRP.Position).Magnitude
				if dist <= maxRange and dist < closestDist then
					closestDist = dist
					closest = pl
				end
			end
		end
	end
	return closest
end

local function getClosestNPC(lpHRP)
    if not lpHRP then return nil end

    local enemiesFolder = workspace:FindFirstChild("Enemies")
    if not enemiesFolder then return nil end

    local closest = nil
    local closestDist = math.huge
    for _, npc in ipairs(enemiesFolder:GetChildren()) do
        if npc:IsA("Model") then
            local hum = npc:FindFirstChildWhichIsA("Humanoid")
            local hrp = getHRP(npc)
            if hum and hum.Health > 0 and hrp then
                local dist = (hrp.Position - lpHRP.Position).Magnitude
                if dist <= maxRange and dist < closestDist then
                    closestDist = dist
                    closest = npc
                end
            end
        end
    end
    return closest
end

local function applyHighlight(targetModel, targetType)
    if not targetModel then return end
    if currentHighlight and currentHighlight.Adornee == targetModel then return end

    if currentHighlight then  
        currentHighlight:Destroy()  
        currentHighlight = nil  
        currentTargetType = nil  
    end  

    local hl = Instance.new("Highlight")  
    hl.FillColor = Color3.fromRGB(255, 255, 0)  
    hl.OutlineColor = Color3.fromRGB(255, 255, 0)  
    hl.FillTransparency = 0.5  
    hl.OutlineTransparency = 0  
    hl.Adornee = targetModel  
    hl.Parent = targetModel  
    currentHighlight = hl  
    currentTargetType = targetType

    VSkillModule:CheckVSkillUsage(SilentAimModule)
end

local function clearHighlight()
    if currentHighlight then
        currentHighlight:Destroy()
        currentHighlight = nil
        currentTargetType = nil
    end
end

RunService.Heartbeat:Connect(function()
    local lpChar = player.char
    if not lpChar then return end
    local lpHRP = lpChar:FindFirstChild("HumanoidRootPart")
    if not lpHRP then return end

    local targetModel = nil

    if SilentAimplayersEnabled then
		local targetplayer = Selectedplayer or getClosestplayer(lpHRP)
		if targetplayer and targetplayer ~= player and targetplayer.char then
			playersaimbot = targetplayer.Name
			local hrp = getHRP(targetplayer.char)
			playersPosition = getPredictedPosition(hrp)
			targetModel = targetplayer.char
			applyHighlight(targetModel, "player")
		else
			playersaimbot, playersPosition = nil, nil
		end
	elseif currentTargetType == "player" then
		playersaimbot, playersPosition = nil, nil
		clearHighlight()
	end

	if SilentAimNPCsEnabled then  
	    local closestNPC = getClosestNPC(lpHRP)  
	    if closestNPC then  
	        NPCaimbot = closestNPC.Name  
	        local hrp = getHRP(closestNPC)  
	        NPCPosition = getPredictedPosition(hrp)  
	        if not targetModel then  
	            targetModel = closestNPC  
	            applyHighlight(targetModel, "NPC")  
	        end  
	    else  
	        NPCaimbot, NPCPosition = nil, nil  
	    end  
	elseif currentTargetType == "NPC" then
	    NPCaimbot, NPCPosition = nil, nil  
	    clearHighlight()
	end
end)


do
    local RootPart = char:WaitForChild("HumanoidRootPart")

    local AimBotPart = nil
    local Nearestplayer = nil
    local Aimbotplayer = true
    local AimbotTap = true
    local MouseModule = RS:WaitForChild("Mouse")
    local Skills = {"Z", "X", "C", "V", "F"}
    local SEARCH_RADIUS = 1000
    local UPDATE_INTERVAL = 0.12

    local function isValidTarget(plr)
        if not plr or plr == player then return false end
        local char = plr.char
        if not char then return false end
        local pp = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
        if not pp then return false end
        if not pp:IsA("BasePart") then return false end
        return true
    end

    task.spawn(function()
        while RunService:IsRunning() do
            local bestDist = math.huge
            local best = nil
            local myPos = RootPart and RootPart.Position
            if not myPos then
                char = player.char or player.charAdded:Wait()
                RootPart = char:FindFirstChild("HumanoidRootPart")
                myPos = RootPart and RootPart.Position
            end

            if myPos then
                for _, plr in pairs(players:Getplayers()) do
                    if isValidTarget(plr) then
                        local pp = plr.char.PrimaryPart or plr.char:FindFirstChild("HumanoidRootPart")
                        if pp then
                            local d = (pp.Position - myPos).Magnitude
                            if d < bestDist and d <= SEARCH_RADIUS then
                                bestDist = d
                                best = plr
                            end
                        end
                    end
                end
            end

            Nearestplayer = best
            task.wait(UPDATE_INTERVAL)
        end
    end)

    task.spawn(function()
        local OldHook
        local ok, hm = pcall(function() return hookmetamethod end)
        if not ok or not hm then
            return
        end

        OldHook = hookmetamethod(game, "__namecall", function(self, V1, V2, ...)
            local Method = getnamecallmethod and getnamecallmethod():lower() or ""
            if tostring(self) == "RemoteEvent" and Method == "fireserver" then
                if typeof(V1) == "Vector3" then
                    if AimBotPart and SilentAimplayersEnabled and SilentAimNPCsEnabled then
                        local part = AimBotPart[1]
                        return OldHook(self, part and part.Position or AimBotPart[2], V2, ...)
                    end

                    if Aimbotplayer and Nearestplayer and Nearestplayer.char then
                        local pp = Nearestplayer.char.PrimaryPart or Nearestplayer.char:FindFirstChild("HumanoidRootPart")
                        return OldHook(self, pp and pp.Position or Nearestplayer.char:GetModelCFrame().p, V2, ...)
                    end
                end
            elseif Method == "invokeserver" then
                if type(V1) == "string" then
                    if V1 == "TAP" and typeof(V2) == "Vector3" then
                        if AimbotTap and Nearestplayer and Nearestplayer.char then
                            local pp = Nearestplayer.char.PrimaryPart or Nearestplayer.char:FindFirstChild("HumanoidRootPart")
                            return OldHook(self, "TAP", pp and pp.Position or Nearestplayer.char:GetModelCFrame().p, ...)
                        end
                    else
                        local Enemie = ...
                        if table.find(Skills, V1) and typeof(V2) == "Vector3" and not Enemie then
                            if AimBotPart and SilentAimplayersEnabled and SilentAimNPCsEnabled then
                                local part = AimBotPart[1]
                                return OldHook(self, part and part.Position or AimBotPart[2], V2, ...)
                            end

                            if Aimbotplayer and Nearestplayer and Nearestplayer.char then
                                local pp = Nearestplayer.char.PrimaryPart or Nearestplayer.char:FindFirstChild("HumanoidRootPart")
                                if pp then
                                    return OldHook(self, V1, pp.Position, pp, ...)
                                else
                                    return OldHook(self, V1, Nearestplayer.char:GetModelCFrame().p, nil, ...)
                                end
                            end
                        end
                    end
                end
            end

            return OldHook(self, V1, V2, ...)
        end)
    end)

    local ok, Mouse = pcall(function() return require(MouseModule) end)
    if ok and Mouse then
        if RootPart then
            Mouse.Hit = CFrame.new(RootPart.Position)
            Mouse.Target = RootPart
        else
            task.spawn(function()
                char = player.char or player.charAdded:Wait()
                RootPart = char:WaitForChild("HumanoidRootPart")
                Mouse.Hit = CFrame.new(RootPart.Position)
                Mouse.Target = RootPart
            end)
        end
    end
end

local HasTag = function(tagName)
  local char = player.char
  if (not char) then return false; end
  return Services.CollectionService:HasTag(char, tagName);
end

task.spawn(function()
	while true do
		local char = player.char or player.charAdded:Wait();
		char:WaitForChild("Humanoid");
		char:WaitForChild("HumanoidRootPart");
		wait(.1);
		if AutoKen then
		    if HasTag("Ken") then
				local playerGui = player:FindFirstChild("playerGui")
		        if playerGui then
		            local kenButton = playerGui:FindFirstChild("MobileContextButtons")
	                and playerGui.MobileContextButtons:FindFirstChild("ContextButtonFrame")
	                and playerGui.MobileContextButtons.ContextButtonFrame:FindFirstChild("BoundActionKen")

		            if kenButton and kenButton:GetAttribute("Selected") ~= true then
		                kenButton:SetAttribute("Selected", true)
		            end
		        end
		
		        local observationManager = getrenv()._G.OM;
		        if (observationManager and not observationManager.active) then
					observationManager.radius = 0
		            observationManager:setActive(true);
		            commE:FireServer("Ken", true);
		        end
		    end
		    wait();
		end
	end
end);

function SilentAimModule:SetAutoKen(state)
	AutoKen = state
end

function SilentAimModule:SetplayerSilentAim(state)
	UserWantsplayerAim = state
	SilentAimplayersEnabled = state
end

function SilentAimModule:SetNPCSilentAim(state)
	UserWantsNPCAim = state
	SilentAimNPCsEnabled = state
end

function SilentAimModule:Pause()
    SilentAimplayersEnabled = false
    SilentAimNPCsEnabled = false
end

function SilentAimModule:Restore()
    SilentAimplayersEnabled = UserWantsplayerAim
    SilentAimNPCsEnabled = UserWantsNPCAim
end

function SilentAimModule:IsplayerAimEnabled()
    return SilentAimplayersEnabled
end

function SilentAimModule:IsNPCAimEnabled()
    return SilentAimNPCsEnabled
end

function SilentAimModule:SetDistanceLimit(num)
	if typeof(num) == "number" then
		maxRange = num
	end
end

function SilentAimModule:SetSelectedplayer(playerName)
	if not playerName or playerName == "" then
		Selectedplayer = nil
		return
	end

	local found = players:FindFirstChild(playerName)
	if found then
		Selectedplayer = found
	end
end

function SilentAimModule:GetSelectedplayer()
	return Selectedplayer and Selectedplayer.Name or "None"
end

function SilentAimModule:SetPrediction(state)
	PredictionEnabled = state
end

function SilentAimModule:SetPredictionAmount(num)
	if typeof(num) == "number" then
		PredictionAmount = num
	end
end

return SilentAimModule
